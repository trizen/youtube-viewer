#!/usr/bin/perl

# Copyright (C) 2010-2012 Trizen <echo dHJpemVueEBnbWFpbC5jb20K | base64 -d>.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#-------------------------------------------------------
#  GTK Youtube Viewer
#  Created on: 12 September 2010
#  Latest edit on: 15 November 2012
#  Website: http://trizen.googlecode.com
#-------------------------------------------------------

use strict;
use 5.010;

#use lib qw(../lib);    # devel only
#use warnings;          # debug only

use Gtk2 qw(-init);
require WWW::YoutubeViewer;
use File::Basename qw(dirname);
use File::Spec::Functions qw(
  rel2abs
  catdir catfile
  curdir updir
  path tmpdir
  );

my $appname  = 'GTK Youtube Viewer';
my $version  = '3.0.4-dev';
my $execname = 'gtk-youtube-viewer';

# Developer key
my $key = 'eTj9NtCyOsGMliTTwz-T85muGT-ARAwVREslfB_giHP3X339Jkpn5Xf71pQXY96xWtFY1oFHt530ct5uZZJk5YTghbNm2IrwZ4';

# Configuration dir/file
my $xdg_config_home = $ENV{XDG_CONFIG_HOME}
  || catdir(($ENV{HOME} || $ENV{LOGDIR} || (getpwuid($<))[7] || `echo -n ~`), '.config');

# Configuration dir/file
my $config_dir = catdir($xdg_config_home, $execname);
my $config_file = catfile($config_dir, "$execname.conf");

if (not -d $config_dir) {
    require File::Path;
    File::Path::make_path($config_dir)
      or warn "[!] Can't create dir '$config_dir': $!";
}

# Unchangeable variables goes here
my %constant = (win32 => $^O =~ /^mswin\d/i || 0,);

# CLI Youtube Viewer
my $cli_youtube_viewer = '/usr/share/gtk-youtube-viewer/youtube-viewer';

if (not -e $cli_youtube_viewer) {
    $cli_youtube_viewer = rel2abs('./youtube-viewer');
}

# Locating gcap
my $gcap;
foreach my $path (path()) {
    if (-e (my $gcap_path = catfile($path, 'gcap'))) {
        $gcap = $gcap_path;
        last;
    }
}

# Get mplayer
sub get_mplayer {
    if ($constant{win32}) {
        my $smplayer = catfile($ENV{ProgramFiles}, qw(SMPlayer mplayer mplayer.exe));

        if (not -e $smplayer) {
            warn "\n\n!!! Please install SMPlayer in order to stream YouTube videos.\n\n";
        }

        return $smplayer;    # Windows MPlayer
    }
    else {
        my $mplayer_path = '/usr/bin/mplayer';
        return -x $mplayer_path ? $mplayer_path : q{mplayer}    # *NIX MPlayer
    }
}

# Main configuration
my %CONFIG = (

    # Combobox values
    active_sort_by_combobox      => 0,
    active_time_sort_by_combobox => 0,
    active_resolution_combobox   => 0,
    active_search_for            => 0,
    active_hd_combobox           => 0,
    active_caption_combobox      => 0,
    active_duration_combobox     => 0,
    active_safe_search_combobox  => 1,
    active_more_options_expander => 0,

    # MPlayer options
    cache             => 30000,
    cache_min         => 5,
    lower_cache       => 1000,
    lower_cache_min   => 3,
    mplayer           => get_mplayer(),
    mplayer_srt_args  => '-unicode -utf8 -sub %s',
    mplayer_arguments => '-prefer-ipv4 -really-quiet -cache %d -cache-min %d',

    # GUI options
    clean_text_entries_on_click => 1,
    show_thumbs                 => 1,
    clear_list                  => 1,
    default_notebook_page       => 1,
    mainw_size                  => '700x400',

    # Youtube options
    prefer_webm         => 0,
    prefer_https        => 0,
    results             => 10,
    resolution          => 'original',
    hd                  => undef,
    safe_search         => undef,
    caption             => undef,
    duration            => undef,
    time                => undef,
    orderby             => undef,
    categories_language => 'en-US',

    # URI options
    thumb_url           => 'http://i.ytimg.com/vi/%s/%s.jpg',
    youtube_video_url   => 'http://www.youtube.com/watch?v=%s',
    playlists_url       => 'http://www.youtube.com/playlist?list=%s',
    youtube_profile_url => 'http://www.youtube.com/user/%s',

    # Subtitle options
    srt_languages => ['en', 'jp'],
    captions_dir  => tmpdir(),
    get_captions  => 1,
    gcap          => $gcap,

    # Others
    http_proxy	    => undef,
    page            => 1,
    debug           => 0,
    fullscreen      => 0,
    use_lower_cache => 0,
    use_threads     => do {
        eval { require threads };
        $@ ? 0 : 1;
    },
    use_threads_for_thumbs => do {
        eval { require threads };
        $@ ? 0 : 1;
    },
    show_comments_by_default => 0,
    hpaned_position          => 420,
    search_channels          => 0,
    search_playlists         => 0,
    auth_key                 => undef,
    thousand_separator       => q{,},
    perl_bin                 => $^X,
    default_thumb            => 'default',
    downloads_folder         => $ENV{'HOME'},
    browser                  => undef,
    terminal                 => find_terminal(),
    cli_youtube_viewer       => $cli_youtube_viewer,
    users_list               => catfile($config_dir, 'youtube_users.txt'),
);

my %MPLAYER;

# MPlayer variable arguments
sub set_mplayer_arguments {
    my ($cache, $cache_min) = @_;
    $MPLAYER{mplayer_arguments} = sprintf $CONFIG{mplayer_arguments}, $cache, $cache_min;
    $MPLAYER{fullscreen} = $CONFIG{fullscreen} ? q{-fs} : q{};
    return 1;
}

{
    my $config_documentation = <<"EOD";
#!/usr/bin/perl

# $appname - configuration file

EOD

    # Save hash config to file
    sub dump_configuration {
        require Data::Dump;
        open my $config_fh, '>', $config_file
          or do { warn "[!] Can't open '${config_file}' for write: $!"; return };
        my $dumped_config = q{our $CONFIG = } . Data::Dump::dump(\%CONFIG);
        print $config_fh $config_documentation, $dumped_config;
        close $config_fh;
    }
}

# Creating config unless it exists
unless (-e $config_file) {
    dump_configuration();
}

# SIG handlers
foreach my $sig (qw(HUP TERM INT KILL)) {
    $SIG{$sig} = \&on_mainw_destroy;
}

# Locating the .glade interface file and icons dir
my ($interface_path, $icons_path);
if (-f (my $glade_file = catfile(updir(), 'share', "$execname.glade"))) {
    $interface_path = rel2abs($glade_file);
    $icons_path = catdir(dirname($interface_path), 'gtk-youtube-viewer-icons');
}
else {
    foreach my $usr_dir (qw(/usr /usr/local . ..)) {
        if (-e ($interface_path = catfile($usr_dir, 'share', $execname, "$execname.glade"))) {
            $icons_path = catdir($usr_dir, 'share', $execname, 'icons');
            last;
        }
    }
}

# Defining GUI
my $gui = 'Gtk2::Builder'->new;
$gui->add_from_file($interface_path);
$gui->connect_signals(undef);

# -------------  Get GUI objects ------------- #
my (
    $mainw,                 $users_list_window,   $help_window,          $prefernces_window,      $login_to_youtube,
    $errors_window,         $details_window,      $about_window,         $treeview,               $liststore,
    $config_view,           $statusbar,           $thumbs_column,        $textview_help,          $sort_combobox,
    $sort_by_time_combobox, $resolution_combobox, $spin_results,         $users_treeview,         $users_liststore,
    $thumbs_checkbutton,    $search_for_combobox, $spin_start_with_page, $fullscreen_checkbutton, $notebook,
    $search_entry,          $from_author_entry,   $gif_spinner,          $hbox2,                  $feeds_window,
    $feeds_treeview,        $feeds_liststore,     $feeds_statusbar,      $safesearch_combobox,    $hd_combobox,
    $caption_combobox,      $duration_combobox,   $warnings_window,      $warnings_textview,      $errors_textview,
    $category_id_entry,     $more_options_expander,
   );

sub get_objects {
    my %objects = (

        # Windows
        '__MAIN__'          => \$mainw,
        'users_list_window' => \$users_list_window,
        'help_window'       => \$help_window,
        'prefernces_window' => \$prefernces_window,
        'errors_window'     => \$errors_window,
        'login_to_youtube'  => \$login_to_youtube,
        'details_window'    => \$details_window,
        'aboutdialog1'      => \$about_window,
        'feeds_window'      => \$feeds_window,
        'warnings_window'   => \$warnings_window,

        # Others
        'treeview1'              => \$users_treeview,
        'feeds_statusbar'        => \$feeds_statusbar,
        'treeview2'              => \$treeview,
        'feeds_treeview'         => \$feeds_treeview,
        'liststore1'             => \$liststore,
        'liststore2'             => \$users_liststore,
        'liststore11'            => \$feeds_liststore,
        'textview3'              => \$config_view,
        'warnings_textview'      => \$warnings_textview,
        'errors_textview'        => \$errors_textview,
        'search_entry'           => \$search_entry,
        'statusbar1'             => \$statusbar,
        'treeviewcolumn2'        => \$thumbs_column,
        'textview2'              => \$textview_help,
        'from_author_entry'      => \$from_author_entry,
        'category_id_entry'      => \$category_id_entry,
        'more_options_expander'  => \$more_options_expander,
        'notebook1'              => \$notebook,
        'combobox1'              => \$sort_combobox,
        'combobox2'              => \$sort_by_time_combobox,
        'combobox3'              => \$resolution_combobox,
        'combobox4'              => \$duration_combobox,
        'combobox5'              => \$caption_combobox,
        'combobox6'              => \$hd_combobox,
        'combobox7'              => \$safesearch_combobox,
        'spinbutton1'            => \$spin_results,
        'spinbutton2'            => \$spin_start_with_page,
        'thumbs_checkbutton'     => \$thumbs_checkbutton,
        'search_for_combobox'    => \$search_for_combobox,
        'fullscreen_checkbutton' => \$fullscreen_checkbutton,
        'gif_spinner'            => \$gif_spinner,
        'hbox2'                  => \$hbox2,
    );

    while (my ($key, $value) = each %objects) {
        ${$value} = $gui->get_object($key);
    }
}
get_objects();

# __WARN__ handle
local $SIG{__WARN__} = sub {
    my $warning = _strip_edge_spaces(join('', @_));
    return if $warning =~ m'\bunhandled exception in callback:';

    $warning = "[" . localtime(time) . "]: " . $warning . "\n";
    print STDERR $warning;

    set_text($warnings_textview, $warning, append => 1);
};

# __DIE__ handle
local $SIG{__DIE__} = sub {
    return if not [caller]->[0] ~~ [qw(main WWW::YoutubeViewer)];
    my $error = join('', @_);
    set_text(
        $errors_textview,
        $error . do {
            if ($error =~ m{^Can't locate (.+?)\.pm\b}) {
                my $module = $1;
                $module =~ s{[/\\]+}{::}g;
                "\nThe module $module is required!\n\nTo install the module, just type in terminal:\n\tsudo cpan $module\n";
            }
          }
          . "\n=>> Previous warnings:\n" . get_text($warnings_textview)
    );
    warn $error;
    $errors_window->show;
    return 1;
};

#---------------------- LOAD IMAGES ----------------------#
my $app_icon_pixbuf  = 'Gtk2::Gdk::Pixbuf'->new_from_file("$icons_path/$execname.png");
my $user_icon_pixbuf = 'Gtk2::Gdk::Pixbuf'->new_from_file_at_size("$icons_path/user.png", 16, 16);
my $feed_icon_pixbuf = 'Gtk2::Gdk::Pixbuf'->new_from_file_at_size("$icons_path/feed_icon.png", 16, 16);
my $default_thumb    = 'Gtk2::Gdk::Pixbuf'->new_from_file_at_size("$icons_path/default_thumb.jpg", 120, 90);
my $animation        = 'Gtk2::Gdk::PixbufAnimation'->new_from_file("$icons_path/spinner.gif");

# Setting application title and icon
$mainw->set_title("$appname $version");
$mainw->set_icon($app_icon_pixbuf);

#------------------------ REGEXP AREA ------------------------#
my $generic_name_re   = qr{[a-zA-Z0-9_.\-]{16,34}};
my $valid_username_re = qr{^(?:\w+(?:[-.]++\w++)*|$generic_name_re)\z};

my $video_id_re       = qr{[0-9A-Za-z_\-]{11}};
my $valid_video_id_re = qr{^$video_id_re\z};
my $get_video_id_re   = qr{(?:%3F|\b)(?>v|embed|youtu[.]be)(?>[=/]|%3D)(?<video_id>$video_id_re)};

my $course_id_re       = qr{EC(?<course_id>$generic_name_re)|(?<course_id>$generic_name_re)};
my $valid_course_id_re = qr{^$course_id_re\z};
my $get_course_id_re   = qr{/course\?list=$course_id_re};

my $valid_playlist_id_re = qr{^$generic_name_re\z};
my $get_playlist_id_re   = qr{(?:(?:(?>playlist\?list|view_play_list\?p)=)|\w#p/c/)(?<playlist_id>$generic_name_re)\b};

{
    my $i = length $key;
    $key =~ s/(.{$i})(.)/$2$1/g while $i--;
}

my $yv_obj = WWW::YoutubeViewer->new(
                                     key         => $key,
                                     app_name    => $appname,
                                     app_version => $version,
                                     escape_utf8 => 1,
                                    );

our $CONFIG;
require $config_file;    # Load the configuration file

if (ref $CONFIG ne 'HASH') {
    $CONFIG = do($config_file) || warn "Can't load the configuration file: $!";
}

my @valid_keys = grep exists $CONFIG{$_}, keys %{$CONFIG};
@CONFIG{@valid_keys} = @{$CONFIG}{@valid_keys};

if (ref $CONFIG ne 'HASH' or not %CONFIG ~~ %{$CONFIG}) {
    dump_configuration();
}

# Set config file to $CONFIG hash ref
sub apply_configuration {

    # Menu items
    $fullscreen_checkbutton->set_active($CONFIG{fullscreen});

    # Others
    foreach my $method_name (
                             qw(
                             caption results duration
                             author orderby region category
                             categories_language safe_search
                             page debug time prefer_https
                             )
      ) {
        my $code = \&{"WWW::YoutubeViewer::set_$method_name"};
        $yv_obj->$code($CONFIG{$method_name});
    }

    # Spin button results setting config value
    $spin_results->set_value($CONFIG{results});

    # Spin button start with page
    $spin_start_with_page->set_value($CONFIG{page});

    # Checking thumbs button
    $thumbs_checkbutton->set_active($CONFIG{show_thumbs});

    # Auto-login
    if (exists $CONFIG{auth_key} and $CONFIG{auth_key}) {
        set_auth_key($CONFIG{auth_key});
    }
    else {
        $statusbar->push(1, 'Not logged');
    }

    # Setup threads
    if ($CONFIG{use_threads}) {
        set_threads();
    }

    # Proxy
    if (defined $CONFIG->{http_proxy})
    {
	my $code = \&{"WWW::YoutubeViewer::set_http_proxy"};
	$yv_obj->$code(delete $CONFIG->{http_proxy});
    }

    # Set the "More options" expander
    $more_options_expander->set_expanded($CONFIG{active_more_options_expander});

    # Combo boxes setting config value
    $sort_combobox->set_active($CONFIG{active_sort_by_combobox});
    $sort_by_time_combobox->set_active($CONFIG{active_time_sort_by_combobox});
    $resolution_combobox->set_active($CONFIG{active_resolution_combobox});
    $search_for_combobox->set_active($CONFIG{active_search_for});
    $hd_combobox->set_active($CONFIG{active_hd_combobox});
    $caption_combobox->set_active($CONFIG{active_caption_combobox});
    $duration_combobox->set_active($CONFIG{active_duration_combobox});
    $safesearch_combobox->set_active($CONFIG{active_safe_search_combobox});

    # Resize the main window
    $mainw->set_default_size(split(/x/i, $CONFIG{mainw_size}, 2));
    $mainw->reshow_with_initial_size;

    # Set HPaned position
    $hbox2->set_position($CONFIG{hpaned_position});

    # Select text from text entry
    $search_entry->select_region(0, -1);
}

# Apply the configuration file
apply_configuration();

# --- ITAGS ---

# itag => resolution
my %itags = (

    $CONFIG{prefer_webm}
    ? (
       45 => 720,    # webm
       44 => 480,    # webm
       43 => 360,    # webm
      )
    : (
       22 => 720,
       35 => 480,
       34 => 360,
      ),

    38 => 'original',
    37 => 1080,
    36 => 180,
    18 => 340,
    5  => 240,
    17 => 144,
);

# resolution => itag
my %resolutions;
@resolutions{values %itags} = keys %itags;

# YouTube usernames
my %users_table = map { lc($_) => $_ } (
                                        'AtGoogleTalks',  'AtheistsAreSkeptics', 'Best0fScience',        'DiscoveryTV',
                                        'Google',         'GoogleChrome',        'GoogleTechTalks',      'KhanAcademy',
                                        'NASAtelevision', 'NatCen4ScienceEd',    'GoogleDevelopers',     'RichardDawkinsDotNet',
                                        'ScienceChannel', 'SpaceRip',            'AnimalPlanetTV',       'TEDtalksDirector',
                                        'MIT',            'SixtySymbols',        'SpitzerScienceCenter', 'EvolutionDocumentary',
                                        'FOSDEMtalks'
                                       );
set_usernames();

sub lwp_get {
    my ($url) = @_;

    $yv_obj->set_lwp_useragent()
      unless defined $yv_obj->{lwp};

    my %lwp_header = $yv_obj->_get_lwp_header();

    my $response = $yv_obj->{lwp}->get($url, %lwp_header);

    if ($response->is_success) {
        return $response->content;
    }
    else {
        warn '[' . $response->status_line() . "] Error occured on URL: $url\n";
    }

    return;
}

# ---------------- Threads ---------------- #
my ($queue, $jobs);

sub set_threads {
    return 1 if defined $queue;

    $gif_spinner->set_from_animation($animation);
    warn "* Initializing threads...\n";

    require threads;
    require Thread::Queue;

    no warnings 'redefine';
    *{WWW::YoutubeViewer::lwp_get} = \&threads_lwp_get;

    $queue = 'Thread::Queue'->new;
    $jobs  = 'Thread::Queue'->new;
    threads->create(
        sub {
            while (defined(my $url = $jobs->dequeue)) {
                $queue->enqueue(lwp_get($url) || q{});
            }
        }
    )->detach();
}

sub threads_lwp_get {
    my ($self, $url) = @_;

    set_threads() unless defined $queue;
    $gif_spinner->show;

    if (not defined $url) {
        $url = $self;
    }

    $jobs->enqueue($url);
    while ($queue->pending == 0) {
        'Gtk2'->main_iteration;
        if (defined(my $lwp_result = $queue->dequeue_nb)) {
            $gif_spinner->hide;
            return $lwp_result;
        }
    }
    undef $queue;
    undef $jobs;
}

# Set text to a 'textview' object
sub set_text {
    my ($object, $text, %args) = @_;
    my $object_buffer = $object->get_buffer;

    if ($args{append}) {
        my $iter = $object_buffer->get_end_iter;
        $object_buffer->insert($iter, $text);
    }
    else {
        $object_buffer->set_text($text);
    }
    $object->set_buffer($object_buffer);
    return 1;
}

# Get text from a 'textview' object
sub get_text {
    my ($object)      = @_;
    my $object_buffer = $object->get_buffer;
    my $start_iter    = $object_buffer->get_start_iter;
    my $end_iter      = $object_buffer->get_end_iter;
    return $object_buffer->get_text($start_iter, $end_iter, undef);
}

# Setting application icons
my $user_icon = $gui->get_object('icon_from_pixbux')->new_from_pixbuf($user_icon_pixbuf);
$gui->get_object('username_list')->set_image($user_icon);
my $feed_icon_image = $gui->get_object('icon_from_pixbux')->new_from_pixbuf($feed_icon_pixbuf);
$gui->get_object('button6')->set_image($feed_icon_image);
my $subscribe_icon = $gui->get_object('icon_from_pixbux')->new_from_pixbuf($feed_icon_pixbuf);
$gui->get_object('button23')->set_image($subscribe_icon);

# Treeview signals
$treeview->signal_connect('button_press_event', \&menu_popup);
$users_treeview->signal_connect('button_press_event', \&users_menu_popup);

# Menu popup
sub menu_popup {
    my ($treeview, $event) = @_;

    #return 0 unless $treeview->get_selection->get_selected();

    if ($event->button != 3) {
        return 0;
    }
    my $menu = $gui->get_object('detailsmenu');
    $menu->popup(undef, undef, undef, undef, $event->button, $event->time);
    return 0;
}

sub users_menu_popup {
    my ($treeview, $event) = @_;
    if ($event->button != 3) {
        return 0;
    }
    my $menu = $gui->get_object('user_option_menu');
    $menu->popup(undef, undef, undef, undef, $event->button, $event->time);
    return 0;
}

# Setting help text
set_text(
    $textview_help, <<"HELP_TEXT"
* Links
    main website: http://trizen.googlecode.com
    development website: https://github.com/trizen/$execname
    developer's website: http://trizen.go.ro

* Developer
    Trizen <trizenx\@gmail.com>

* Contributor
    Ovidiu D. Ni\x{21b}an <nitanovidiu\@gmail.com>

* Config file
    $config_file

* Users list
    $CONFIG{users_list}

* Key binds

-Main window
CTRL+H : help window
CTRL+L : login window
CTRL+P : preferences window
CTRL+U : username list window
CTRL+Y : CLI youtube viewer
CTRL+D : video details window
CTRL+F : show feeds window
CTRL+W : show the warnings window
CTRL+G : show videos favorited by the author of a selected video
CTRL+R : show related videos for a selected video
CTRL+M : show videos from the author of a selected video
CTRL+K : show playlists from the author of a selected video
CTRL+S : add the author name of a selected video into the users list
CTRL+Q : close the application
DEL : remove the selected video from the list
F11 : minimize-maximize the main window

-Preferences window
CTRL+S : save the configuration

-Other windows
ESC : close the focused window

* Video tops

Valid categories are:
    @{[@{WWW::YoutubeViewer::categories_IDs}]}

Valid region IDs are:
    @{[@{WWW::YoutubeViewer::region_IDs}]}

* Configuration

use_threads
    1 to use threads when getting the XML content

use_threads_for_thumbs
    1 to use threads when getting the thumbnails

cache & cache_min
    this cache values are used for resolutions higher than 480p

lower_cache & lower_cache_min
    this cache values are used for resolutions lower than 720p

use_lower_cache
    1 to always use the lower_cache (for slow connections)

show_thumbs
    1 to show YouTube video thumbnails (may be slow)

clear_list
    1 to clean the treeview list before each search

gcap
    path to gcap application ( see http://gcap.googlecode.com )

srt_languages
    default subtitle languages (when gcap is available)

captions_dir
    is used to store the closed captions from YouTube (.srt files)

* Knowledge:
    http://code.google.com/intl/ro/apis/youtube/2.0/developers_guide_protocol_api_query_parameters.html
HELP_TEXT
        );

# ------------------- Accels ------------------- #

# Main window
my $accel = Gtk2::AccelGroup->new;
$accel->connect(ord('h'), ['control-mask'], ['visible'], \&show_help_window);
$accel->connect(ord('l'), ['control-mask'], ['visible'], \&show_login_to_youtube_window);
$accel->connect(ord('p'), ['control-mask'], ['visible'], \&show_preferences_window);
$accel->connect(ord('q'), ['control-mask'], ['visible'], \&on_mainw_destroy);
$accel->connect(ord('u'), ['control-mask'], ['visible'], \&show_users_list_window);
$accel->connect(ord('y'), ['control-mask'], ['visible'], \&run_cli_youtube_viewer);
$accel->connect(ord('d'), ['control-mask'], ['visible'], \&show_details_window);
$accel->connect(ord('f'), ['control-mask'], ['visible'], \&show_feeds_window);
$accel->connect(ord('s'), ['control-mask'], ['visible'], \&add_user_to_favorites);
$accel->connect(ord('r'), ['control-mask'], ['visible'], \&show_related_videos);
$accel->connect(ord('g'), ['control-mask'], ['visible'], \&get_user_favorited_videos);
$accel->connect(ord('m'), ['control-mask'], ['visible'], \&show_more_videos_from_username);
$accel->connect(ord('k'), ['control-mask'], ['visible'], \&show_playlists_from_username);
$accel->connect(ord('w'), ['control-mask'], ['visible'], \&show_warnings_window);
$accel->connect(0xffff,   ['lock-mask'],    ['visible'], \&delete_selected_row);
$accel->connect(0xffc8,   ['lock-mask'],    ['visible'], \&maximize_unmaximize_mainw);
$mainw->add_accel_group($accel);

# Other windows (ESC key to close them)
$accel = Gtk2::AccelGroup->new;
$accel->connect(0xff1b, ['lock-mask'], ['visible'], \&hide_users_list_window);
$users_list_window->add_accel_group($accel);

$accel = Gtk2::AccelGroup->new;
$accel->connect(0xff1b, ['lock-mask'], ['visible'], \&hide_feeds_window);
$feeds_window->add_accel_group($accel);

$accel = Gtk2::AccelGroup->new;
$accel->connect(0xff1b,   ['lock-mask'],    ['visible'], \&hide_preferences_window);
$accel->connect(ord('s'), ['control-mask'], ['visible'], \&save_configuration);
$prefernces_window->add_accel_group($accel);

$accel = Gtk2::AccelGroup->new;
$accel->connect(0xff1b, ['lock-mask'], ['visible'], \&hide_help_window);
$help_window->add_accel_group($accel);

$accel = Gtk2::AccelGroup->new;
$accel->connect(0xff1b, ['lock-mask'], ['visible'], \&hide_details_window);
$details_window->add_accel_group($accel);

# ------------------ Authentication ------------------ #

sub set_auth_key {
    my ($auth_key) = @_;
    $yv_obj->set_auth_key($auth_key) or return;
    change_subscription_page(1);
    $statusbar->push(1, "Logged.");
    return 1;
}

sub authenticate {
    my $email    = $gui->get_object('email')->get_text;
    my $password = $gui->get_object('password')->get_text;

    my $auth_key = $yv_obj->login($email, $password);

    hide_login_to_youtube_window();

    if (defined $auth_key) {
        if ($gui->get_object('login_check_button')->get_active) {
            $CONFIG{auth_key} = $auth_key;
            dump_configuration();
        }
        set_auth_key($auth_key);
        return 1;
    }
    return;
}

# ------------------ Showing/Hidding windows ------------------ #

# Main window
sub maximize_unmaximize_mainw {
    state $maximized = 0;
    $maximized++ % 2
      ? $mainw->unfullscreen
      : $mainw->fullscreen;
}

# Users list window
sub show_users_list_window {
    $users_list_window->show;
    return 1;
}

sub hide_users_list_window {
    $users_list_window->hide;
    return 1;
}

# Help window
sub show_help_window {
    $help_window->show;
    return 1;
}

sub hide_help_window {
    $help_window->hide;
    return 1;
}

# Warnings window

sub show_warnings_window {
    $warnings_window->show;
    return 1;
}

sub hide_warnings_window {
    $warnings_window->hide;
    return 1;
}

# About Window
sub show_about_window {
    $about_window->set_program_name("$appname $version");
    $about_window->set_logo($app_icon_pixbuf);
    $about_window->set_resizable(1);
    $about_window->show;
    return 1;
}

sub hide_about_window {
    $about_window->hide;
    return 1;
}

# Error window
sub hide_errors_window {
    $errors_window->hide;
    return 1;
}

# Login window
sub show_login_to_youtube_window {
    $login_to_youtube->show;
    return 1;
}

sub hide_login_to_youtube_window {
    $login_to_youtube->hide;
    return 1;
}

# Details window
sub show_details_window {
    my ($code, $iter) = get_selected_video_code() or return;

    #return unless $code =~ /$valid_video_id_re/;
    $details_window->show;
    set_video_details($code, $iter);
    return 1;
}

sub hide_details_window {
    $details_window->hide;
    return 1;
}

sub set_comments {
    my $videoID = get_selected_video_code() or return;

    return unless $videoID =~ /$valid_video_id_re/;

    $feeds_liststore->clear;
    print_comments($yv_obj->get_video_comments($videoID));
}

# Feeds window
sub show_feeds_window {
    my $videoID = get_selected_video_code() or return;

    return unless $videoID =~ /$valid_video_id_re/;

    $feeds_window->show;
    $feeds_statusbar->pop(0);

    print_comments($yv_obj->get_video_comments($videoID));

    return 1;
}

sub hide_feeds_window {
    $feeds_liststore->clear;
    $feeds_window->hide;
    return 1;
}

# Preferences window
sub show_preferences_window {
    require Data::Dump;
    get_main_window_size();
    my $config_view_buffer = $config_view->get_buffer;
    $config_view_buffer->set_text(Data::Dump::dump(\%CONFIG));
    $config_view->set_buffer($config_view_buffer);
    $prefernces_window->show;
    return 1;
}

sub hide_preferences_window {
    $prefernces_window->hide;
    return 1;
}

# Save plaintext config to file
sub save_configuration {
    my $config = get_text($config_view);

    my $hash_ref = eval $config;
    die $@ if $@;

    %CONFIG = %{$hash_ref};
    dump_configuration();

    apply_configuration();
    hide_preferences_window();
    return 1;
}

sub delete_selected_row {
    my (undef, $iter) = get_selected_video_code() or return;
    $liststore->remove($iter);
    return 1;
}

# Combo boxes changes
sub combobox_sort_by_changed {
    $CONFIG{active_sort_by_combobox} = $sort_combobox->get_active;
    $yv_obj->set_orderby($CONFIG{orderby} = $sort_combobox->get_active_text);
}

sub combobox_time_sort_by_changed {
    $CONFIG{active_time_sort_by_combobox} = $sort_by_time_combobox->get_active;
    $yv_obj->set_time($CONFIG{time_sort} = $sort_by_time_combobox->get_active_text);
}

sub combobox_resolution_changed {
    $CONFIG{active_resolution_combobox} = $resolution_combobox->get_active;
    my $res = $resolution_combobox->get_active_text;
    $CONFIG{resolution} = $res =~ /^(\d+)p\z/ ? $1 : $res;
}

sub combobox_search_for_changed {
    state $labels = [qw(videos playlists channels)];
    $CONFIG{active_search_for} = $search_for_combobox->get_active;
    $CONFIG{"search_$_"} = 0 for @{$labels};
    $CONFIG{"search_" . $search_for_combobox->get_active_text} = 1;
}

sub combobox_safesearch_changed {
    $CONFIG{active_safe_search_combobox} = $safesearch_combobox->get_active;
    $yv_obj->set_safe_search($CONFIG{safe_search} = $safesearch_combobox->get_active_text);
}

sub combobox_duration_changed {
    my $text = $duration_combobox->get_active_text;
    $CONFIG{active_duration_combobox} = $duration_combobox->get_active;
    $yv_obj->set_duration($CONFIG{duration} = $text eq 'default' ? undef : $text);
}

sub combobox_caption_changed {
    my $text = $caption_combobox->get_active_text;
    $CONFIG{active_caption_combobox} = $caption_combobox->get_active;
    $yv_obj->set_caption($CONFIG{only_videos_with_caption} = $text eq 'default' ? undef : $text);
}

sub combobox_hd_changed {
    my $text = $hd_combobox->get_active_text;
    $CONFIG{active_hd_combobox} = $hd_combobox->get_active;
    $yv_obj->set_hd($CONFIG{only_hd_videos} = $text eq 'default' ? undef : $text);
}

# Spin buttons changes
sub spin_results_per_page_changed {
    $yv_obj->set_results($CONFIG{results} = $spin_results->get_value);
}

sub spin_start_with_page_changed {
    $yv_obj->set_page($CONFIG{page} = $spin_start_with_page->get_value);
}

# Menu items
sub toggled_mplayer_fullscreen {
    $CONFIG{fullscreen} = $fullscreen_checkbutton->get_active() || 0;
}

# Check buttons toggles
sub thumbs_checkbutton_toggled {
    $CONFIG{show_thumbs} = ($_[0]->get_active() || 0);
    $thumbs_column->set_visible($CONFIG{show_thumbs});
}

# "More options" expander
sub activate_more_options_expander {
    $CONFIG{active_more_options_expander} = $_[0]->get_expanded() ? 0 : 1;
}

# Get main window size
sub get_main_window_size {
    $CONFIG{mainw_size} = join('x', $mainw->get_size);
}

my $cat_treeview   = $gui->get_object('treeview3');
my $cats_liststore = $gui->get_object('liststore4');

my $categories = [['Film &amp; Animation'      => 'Film'],
                  ['Autos &amp; Vehicles'      => 'Autos'],
                  ['Music'                     => 'Music'],
                  ['Pets &amp; Animals'        => 'Animals'],
                  ['Sports'                    => 'Sports'],
                  ['Travel &amp; Events'       => 'Travel'],
                  ['Gaming'                    => 'Games'],
                  ['Comedy'                    => 'Comedy'],
                  ['People &amp; Blogs'        => 'People'],
                  ['News &amp; Politics'       => 'News'],
                  ['Entertainment'             => 'Entertainment'],
                  ['Education'                 => 'Education'],
                  ['Howto &amp; Style'         => 'Howto'],
                  ['Nonprofits &amp; Activism' => 'Nonprofit'],
                  ['Science &amp; Technology'  => 'Tech'],
                  ['Movies'                    => 'Movies'],
                  ['Trailers'                  => 'Trailers'],
                 ];

{
    my $iter = $cats_liststore->append;
    $cats_liststore->set($iter, 0, "<big><b>\tCategories</b></big>");
}

my $i = 0;
while (defined $categories->[$i][0]) {
    my ($key, $value) = @{$categories->[$i++]};
    my $iter = $cats_liststore->append;
    $cats_liststore->set($iter, 0, $key);
    $cats_liststore->set($iter, 1, $value);
    $cats_liststore->set($iter, 2, $feed_icon_pixbuf);
}

my $tops_liststore = $gui->get_object('liststore6');
my $tops_treeview  = $gui->get_object('treeview4');

sub add_top_row {
    my ($top_name, $top_type) = @_;
    (my $top_label = ucfirst $top_name) =~ tr/_/ /;
    my $iter = $tops_liststore->append;
    $tops_liststore->set($iter, 0, $top_label);
    $tops_liststore->set($iter, 1, $feed_icon_pixbuf);
    $tops_liststore->set($iter, 2, $top_name);
    $tops_liststore->set($iter, 3, $top_type);
}

sub set_youtube_tops {
    my ($top_time, $main_label) = @_;

    my $iter = $tops_liststore->append;
    $tops_liststore->set($iter, 0, "<big><b>\t$main_label</b></big>");

    my $i = 0;
    foreach my $top_name (@{WWW::YoutubeViewer::feeds_IDs}) {

        my $top_time_copy = $top_time;
        if (++$i ~~ [3, 5, 8, 9]) {    # doesn't support the 'time' option
            $top_time_copy = $top_time eq 'today' ? q{} : next;
        }

        add_top_row($top_name, $top_time_copy);
    }
}

set_youtube_tops('today',    'Today tops');
set_youtube_tops('all_time', 'All time tops');

{
    my $iter = $tops_liststore->append;
    $tops_liststore->set($iter, 0, "<big><b>\tMovies</b></big>");
    foreach my $movie_top (@{WWW::YoutubeViewer::movie_IDs}) {
        add_top_row($movie_top, 'movies');
    }
}

# ------------ Usernames list window ------------ #
sub set_usernames {
    if (-e $CONFIG{users_list}) {
        open my $fh, '<', $CONFIG{users_list};
        while (defined(my $user = <$fh>)) {
            chomp $user;
            $users_table{lc $user} = $user;
        }
        close $fh;
    }
    foreach my $user (sort { lc $a cmp lc $b } values %users_table) {
        my $iter = $users_liststore->append;
        $users_liststore->set($iter, 0, $user);
        $users_liststore->set($iter, 1, $user_icon_pixbuf);
    }
}

sub add_username {
    my $user = $gui->get_object('username_entry')->get_text;
    $users_table{lc $user} = $user;
    my $iter = $users_liststore->append;
    $users_liststore->set($iter, 0, $user);
    $users_liststore->set($iter, 1, $user_icon_pixbuf);
}

sub add_user_to_favorites {
    my $user = get_username_for_selected_video() or return;
    $gui->get_object('username_entry')->set_text($user);
    add_username();
    $feeds_statusbar->push(0, "Successfully added '${user}' into the username list (see: Menu->Users)");
}

sub remove_selected_user {
    my $iter = $users_treeview->get_selection->get_selected;
    my $selected_user = $users_liststore->get($iter, 0);
    delete $users_table{lc $selected_user};
    $users_liststore->remove($iter);
}

sub save_usernames_to_file {
    open my $fh, '>', $CONFIG{users_list} or return 0;
    local $, = "\n";
    print $fh sort { lc $a cmp lc $b } values %users_table;
    close $fh;
}

# ----- My panel settings ----- #
sub log_out {
    change_subscription_page(0);
    undef $CONFIG{auth_key};
    dump_configuration();
    $yv_obj->set_auth_key();
    $statusbar->push(1, "Not logged.");
    return 1;
}

sub change_subscription_page {
    my ($value) = @_;
    foreach my $object (qw(subsc_scrollwindow subsc_label)) {
        $value
          ? $gui->get_object($object)->show
          : $gui->get_object($object)->hide;
    }
    return 1;
}

{
    no strict 'refs';
    foreach my $feed_name (@{WWW::YoutubeViewer::feed_methods}) {
        *{__PACKAGE__ . '::' . $feed_name} = sub {
            my $user   = $gui->get_object('news_users')->get_text;
            my $code   = \&{"WWW::YoutubeViewer::get_$feed_name"};
            my $videos = $yv_obj->$code($user);

            if (defined $videos) {
                $liststore->clear if $CONFIG{clear_list};
                print_videos($videos);
            }
        };
    }
}

sub get_selected_video_code {
    my (%options) = @_;
    my $iter = $treeview->get_selection->get_selected or return;
    unless ($options{force}) {
        return unless defined $liststore->get($iter, 4);
    }
    my $code = $liststore->get($iter, 3);
    return wantarray ? ($code, $iter) : $code;
}

# Check if keywords are actually something else
sub check_keywords {
    given ($_[0]) {
        when (/$get_video_id_re/o) {
            my $info = $yv_obj->get_video_info($+{video_id});
            play_videos($info->{results});
            return 1;
        }
        when (/$valid_playlist_id_re/o) {
            list_playlist($_);
            return 1;
        }
        when (/$get_playlist_id_re/o) {
            list_playlist($+{playlist_id});
            return 1;
        }
        when (/$get_course_id_re/) {
            print_videos($yv_obj->get_video_lectures_from_course($+{course_id}));
            return 1;
        }
    }
    return;
}

sub search {
    my $keywords = $search_entry->get_text();

    return if check_keywords($keywords);

    $liststore->clear if $CONFIG{clear_list};
    $yv_obj->set_author($from_author_entry->get_text);
    $yv_obj->set_category($category_id_entry->get_text);

    if ($CONFIG{search_playlists}) {
        print_playlists($yv_obj->search_for_playlists($keywords));
    }
    elsif ($CONFIG{search_channels}) {
        print_channels($yv_obj->search_channels($keywords));
    }
    else {
        print_videos($yv_obj->search($keywords));
    }

    return 1;
}

#---------------------- PRINT VIDEO RESULTS ----------------------#
sub encode_entities {
    my ($text) = @_;
    $text =~ s/&/&amp;/g;
    $text =~ s/</&lt;/g;
    $text =~ s/>/&gt;/g;
    return $text;
}

sub decode_entities {
    require HTML::Entities;
    return HTML::Entities::decode_entities($_[0]);
}

sub get_next_page_spaces {
    $CONFIG{show_thumbs} ? "\t" x 10 : "\t" x 20;
}

sub get_code {
    my ($code, $iter) = get_selected_video_code(force => 1) or return;

    $code =~ /$valid_playlist_id_re/
      ? do { list_playlist($code) }
      : $code =~ m{^https?://} ? do {

        my $search_type = $liststore->get($iter, 5);

        if ($yv_obj->get_debug) {
            say $search_type if defined $search_type;
        }

        my %args;
        if (defined $search_type and $search_type ne q{}) {
            $args{$search_type} = 1;
        }

        my $results = $yv_obj->next_page($code, %args);

        if (@{$results->{results}}) {
            $liststore->set(
                $iter, 0,
                get_next_page_spaces() . do {
                    $code =~ /[&?]start-index=(\d+)/;
                    '<big><b>Page: ' . ((($1 - 1) / $CONFIG{results}) + 2) . '</b></big>';
                  }
            );
            $liststore->set($iter, 3, q{});
        }
        else {
            $liststore->remove($iter);
            die "This is the last page!\n";
        }

            $args{playlists} ? print_playlists($results)
          : $args{channels}  ? print_channels($results)
          :                    print_videos($results);
      }
      : $code =~ /^username=(.+)/i    ? videos_from_username($1)
      : $code =~ /$valid_video_id_re/ ? play_videos([{videoID => $code}])
      :                                 return;
}

sub _make_row_description {
    (my $row_description = join(q{ }, split(q{ }, $_[0]))) =~ s/(.)\1{3,}/$1/sg;
    return $row_description;
}

sub _append_next_page {
    my ($url, $search_type) = @_;
    my $iter = $liststore->append;
    $liststore->set($iter, 0, get_next_page_spaces() . "<big><b>NEXT PAGE</b></big>");
    $liststore->set($iter, 3, $url);
    $liststore->set($iter, 5, $search_type);
}

sub _get_pixbuf_thumbnail {
    my ($url) = @_;

    my $thumbnail =
      $CONFIG{use_threads_for_thumbs}
      ? threads_lwp_get($url)
      : $yv_obj->lwp_get($url);

    my $pixbuf;
    if ($thumbnail) {
        my $pixbufloader = 'Gtk2::Gdk::PixbufLoader'->new;
        $pixbufloader->set_size(120, 90);
        $pixbufloader->write($thumbnail);
        $pixbuf = $pixbufloader->get_pixbuf;
        $pixbufloader->close;
    }
    else {
        $pixbuf = $default_thumb;
    }

    return $pixbuf;
}

sub print_videos {
    my ($results) = @_;

    my $url    = $results->{url};
    my $videos = $results->{results};

    unless (@{$videos}) {
        die "No video results...\n";
    }

    hide_feeds_window();
    $search_for_combobox->set_active(0);

    foreach my $video (@{$videos}) {
        my $iter = $liststore->append;

        my $row_description = $video->{description} || 'No description available...';
        $liststore->set($iter, 4, $row_description);
        $liststore->set($iter, 6, $video->{author});
        $row_description = _make_row_description($row_description);

        $liststore->set($iter, 3, $video->{videoID});
        $liststore->set(
                        $iter,
                        0,
                        "<big><b>"
                          . encode_entities($video->{title} // 'Unknown')
                          . "</b></big>\n\n"
                          . "<b>Likes\t:</b> "
                          . set_thousands($video->{likes}) . "\n"
                          . "<b>Dislikes\t:</b> "
                          . set_thousands($video->{dislikes}) . "\n"
                          . "<b>Favorited\t:</b> "
                          . set_thousands($video->{favorited}) . "\n"
                          . "<b>Category\t:</b> "
                          . encode_entities($video->{category} // 'Unknown') . "\n"
                          . "<b>Publisher\t: </b>"
                          . $video->{name} . "\n\n" . "<i>"
                          . encode_entities($row_description) . "</i>"
                       );

        $liststore->set(
            $iter, 2,
            "<b>Length\t:</b> "
              . format_time($video->{duration}) . "\n"
              . "<b>Rating\t:</b> "
              . sprintf('%.2f', ($video->{rating} || 0)) . "\n"
              . "<b>Views\t:</b> "
              . set_thousands($video->{views})
              . do {
                defined $video->{published}
                  ? "\n" . "<b>Added\t: </b>" . format_date($video->{published})
                  : q{};
              }
        );

        if ($CONFIG{show_thumbs}) {
            my $thumb_url = sprintf($CONFIG{thumb_url}, $video->{videoID}, $CONFIG{default_thumb});
            my $pixbuf = _get_pixbuf_thumbnail($thumb_url);
            $liststore->set_value($iter, 1, $pixbuf);
        }
    }

    _append_next_page($url);
}

sub print_channels {
    my ($results) = @_;

    my $url      = $results->{url};
    my $channels = $results->{results};

    unless (@{$channels}) {
        die "No channel results...\n";
    }

    $search_for_combobox->set_active(1);

    foreach my $channel (@{$channels}) {
        my $iter = $liststore->append;
        my $row_description = $channel->{summary} || 'No description available...';

        $liststore->set($iter, 4, $row_description);
        $row_description = _make_row_description($row_description);

        $channel->{title} =~ s{<.*?>}{}sg;
        $channel->{title} = decode_entities($channel->{title})
          if $channel->{title} =~ /&#?\w/;

        $liststore->set($iter, 3, "username=$channel->{author}");
        $liststore->set(
                        $iter,
                        0,
                        '<big><b>'
                          . encode_entities($channel->{title})
                          . "</b></big>\n\n"
                          . "<b>Author\t:</b> "
                          . $channel->{name} . "\n"
                          . "<b>Subscr\t:</b> "
                          . set_thousands($channel->{subscribers}) . "\n"
                          . "<b>Views\t:</b> "
                          . set_thousands($channel->{views}) . "\n\n" . '<i>'
                          . encode_entities($row_description) . '</i>'
                       );

        $liststore->set($iter, 2, "<b>Updated:</b> " . format_date($channel->{updated}) . "\n\n");

        if ($CONFIG{show_thumbs}) {
            my $pixbuf = _get_pixbuf_thumbnail($channel->{thumbnail});
            $liststore->set_value($iter, 1, $pixbuf);
        }
    }

    _append_next_page($url, 'channels');
}

#---------------------- PRINT PLAYLISTS ----------------------#
sub print_playlists {
    my ($results) = @_;

    my $url       = $results->{url};
    my $playlists = $results->{results};

    unless (@{$playlists}) {
        die "No playlist results...\n";
    }

    hide_feeds_window();
    $search_for_combobox->set_active(2);

    foreach my $playlist (@{$playlists}) {

        next if $playlist->{count} == 0;

        my $iter = $liststore->append;
        my $row_description = $playlist->{summary} || 'No description available...';

        $liststore->set($iter, 4, $row_description);
        $row_description = _make_row_description($row_description);

        $liststore->set($iter, 6, $playlist->{author});
        $liststore->set($iter, 3, $playlist->{playlistID});
        $liststore->set(
                        $iter,
                        0,
                        '<big><b>'
                          . encode_entities($playlist->{'title'})
                          . "</b></big>\n\n"
                          . "<b>Author\t:</b> "
                          . $playlist->{name} . "\n"
                          . "<b>Published\t:</b> "
                          . format_date($playlist->{published}) . "\n"
                          . "<b>Updated\t:</b> "
                          . format_date($playlist->{updated}) . "\n\n" . '<i>'
                          . encode_entities($row_description) . '</i>'
                       );

        $liststore->set($iter, 2, "<b>Videos:</b> " . set_thousands($playlist->{count}) . "\n\n");

        if ($CONFIG{show_thumbs}) {
            my $pixbuf = _get_pixbuf_thumbnail($playlist->{thumbnail});
            $liststore->set_value($iter, 1, $pixbuf);
        }
    }

    _append_next_page($url, 'playlists');
}

sub list_playlist {
    my ($playlistID) = @_;

    my $info = $yv_obj->get_videos_from_playlist($playlistID);
    if (@{$info->{results}}) {
        $liststore->clear if $CONFIG{clear_list};
        print_videos($info);
        return 1;
    }
    else {
        die "[!] Inexistent playlist...\n";
    }
    return;
}

# Get playlists from username
sub playlists_from_selected_username {
    my $iter = $users_treeview->get_selection->get_selected;
    playlists_from_username($users_liststore->get($iter, 0));
}

sub videos_from_selected_username {
    my $iter = $users_treeview->get_selection->get_selected;
    my $username = $users_liststore->get($iter, 0);
    videos_from_username($username);
}

sub get_username_from_list {
    hide_users_list_window();
    videos_from_selected_username();
}

sub videos_from_text_entry_username {
    videos_from_username($_[0]->get_text);
}

# Get videos from username
sub videos_from_username {
    my ($username) = @_;
    is_valid_username($username) or return;

    my $videos = $yv_obj->get_videos_from_username($username);
    if (@{$videos->{results}}) {
        $liststore->clear if $CONFIG{clear_list};
        print_videos($videos);
    }
    else {
        die "No video uploaded by: <$username>\n";
    }
    return 1;
}

sub favorited_videos_from_username {
    my $username = ref $_[0] ? $_[0]->get_text : $_[0];

    is_valid_username($username) or return;
    my $videos = $yv_obj->get_favorited_videos_from_username($username);
    if (@{$videos->{results}}) {
        $liststore->clear if $CONFIG{clear_list};
        print_videos($videos);
    }
    else {
        die "No video favorited by username: <$username>\n";
    }
    return 1;
}

sub is_valid_username {
    my ($username) = @_;
    die "Invalid username: <$username>\n"
      unless $username =~ /$valid_username_re/;
    return 1;
}

sub playlists_from_username {
    my $username = ref $_[0] ? $_[0]->get_text : $_[0];
    is_valid_username($username) or return;

    my $playlists = $yv_obj->get_playlists_from_username($username);
    if (@{$playlists->{results}}) {
        $liststore->clear if $CONFIG{clear_list};
        print_playlists($playlists);
    }
    else {
        die "No playlists found.\n";
    }
}

sub _find_streaming_url {
    my ($urls_ref, $wanted_itag) = @_;

    my $streaming;
    foreach my $url_ref (@{$urls_ref}) {
        if (exists $url_ref->{itag}) {

            if (defined $wanted_itag) {
                next unless $url_ref->{itag} == $wanted_itag;
            }

            next unless exists $url_ref->{url};
            next unless exists $itags{$url_ref->{itag}};

            $streaming = $url_ref;
            last;
        }
    }
    return $streaming;
}

sub _strip_edge_spaces {
    my ($text) = @_;
    $text =~ s/^\s+//;
    return unpack 'A*', $text;
}

sub get_streaming_url {
    my ($video_id) = @_;

    my @urls = $yv_obj->get_streaming_urls($video_id)
      or die "Can't get the streaming URLs for videoID: $video_id.\n";

    my $srt_file;

    my $has_cc;
    foreach my $url (@urls) {
        if (exists $url->{has_cc} and $url->{has_cc} =~ /^(?:true|yes)$/i) {
            $has_cc = 1;
            last;
        }
    }

    # Download the closed-captions
    if ($has_cc and $CONFIG{get_captions} and defined $CONFIG{gcap}) {
        $srt_file = download_caption($video_id);
    }

    my $streaming = _find_streaming_url(\@urls, $resolutions{$CONFIG{resolution}});

    if (not defined $streaming) {
        $streaming = _find_streaming_url(\@urls);
    }

    my $info = @urls && ref $urls[-1] eq 'HASH' && exists $urls[-1]{status} ? $urls[-1] : {};

    return {
            streaming => $streaming,
            srt_file  => $srt_file,
            info      => $info,
           };
}

sub update_mplayer_arguments {
    my ($resolution) = @_;

    if ($CONFIG{use_lower_cache}
        or not $resolution ~~ [qw(original 1080 720)]) {
        set_mplayer_arguments($CONFIG{lower_cache}, $CONFIG{lower_cache_min});
    }
    else {
        set_mplayer_arguments($CONFIG{cache}, $CONFIG{cache_min});
    }
}

sub get_quotewords {
    require Text::ParseWords;
    return Text::ParseWords::quotewords(@_);
}

#---------------------- PLAY AN YOUTUBE VIDEO ----------------------#
sub play_videos {
    my ($videos) = @_;

    foreach my $video (@{$videos}) {
        my $streaming = get_streaming_url($video->{videoID});

        if (defined $streaming->{info}{status} and not $streaming->{info}{status} =~ /^(?:ok|success)/i) {
            die "(x_x) Can't stream: " . sprintf($CONFIG{youtube_video_url}, $video->{videoID}) . "\n",
              "(x_x) Status: $streaming->{info}{status}", 'bold red' . "\n\n";
        }

        if (not defined $streaming->{streaming}) {
            next;
        }

        update_mplayer_arguments($itags{$streaming->{streaming}{itag}});
        my @mplayer_line =
          get_quotewords(
                         qr/\s+/, 1,
                         join(
                              q{ },
                              $CONFIG{mplayer},
                              (
                               defined $streaming->{srt_file}
                               ? sprintf($CONFIG{mplayer_srt_args}, $streaming->{srt_file})
                               : q{}
                              ),
                              grep { defined and /\S/ } values %MPLAYER
                             )
                        );

        say "@mplayer_line" if $yv_obj->get_debug;

	my $proxy_url = $CONFIG{http_proxy};
	$proxy_url =~ s/http:\/\//http_proxy:\/\//;
	$streaming->{streaming}{url} = $proxy_url . $streaming->{streaming}{url};
        system join(q{ }, map { quotemeta } @mplayer_line, $streaming->{streaming}{url}) . q{ &};
        return if $?;
    }

    return 1;
}

# Thousand separator
sub set_thousands {    # ugly, but fast
    return 0 unless $_[0];
    length($_[0]) > 3 or return $_[0];
    my $n = shift;
    my $l = length($n) - 3;
    my $i = ($l - 1) % 3 + 1;
    my $x = substr($n, 0, $i) . $CONFIG{thousand_separator};
    while ($i < $l) {
        $x .= substr($n, $i, 3) . $CONFIG{thousand_separator};
        $i += 3;
    }
    $x . substr($n, $i);
}

sub format_time {
    my ($sec) = @_;
    $sec >= 3600
      ? join q{:}, map { sprintf '%02d', $_ } $sec / 3600 % 24, $sec / 60 % 60, $sec % 60
      : join q{:}, map { sprintf '%02d', $_ } $sec / 60 % 60, $sec % 60;
}

sub format_date {
    my ($date) = @_;

    # 2010-05-04T00:25:55.000Z
    # to: 04 May 2010

    state $months = [
        qw(
          Jan Feb Mar
          Apr May Jun
          Jul Aug Sep
          Oct Nov Dec
          )
    ];

    $date =~ s{^
    (?<year>\d{4})
           -
    (?<month>\d{2})
           -
    (?<day>\d{2})
        .*
    }
    {$+{day} $months->[$+{month} - 1] $+{year}}x;

    return $date;
}

# Getting YouTube closed captions with gcap
sub download_caption {
    my ($code) = @_;

    my $main_cwd = rel2abs(curdir());

    if (not -d $CONFIG{captions_dir}) {
        require File::Path;
        File::Path::make_path($CONFIG{captions_dir}) or do {
            warn "[!] Can't create directory $CONFIG{captions_dir}: $!\n";
            return;
        };
    }
    elsif (not -w _) {
        warn "[!] Can't write into directory: $CONFIG{captions_dir}\n";
    }

    chdir $CONFIG{captions_dir};

    my $i = 0;
    my $srt_file;
    {
        foreach my $lang (@{$CONFIG{srt_languages}}) {
            my $name = "${code}_${lang}.srt";
            if (-e $name) {
                $srt_file = rel2abs($name);
                last;
            }
        }

        if (not defined $srt_file) {
            if (opendir(my $dir_h, curdir())) {
                while (defined(my $file = readdir $dir_h)) {
                    if ($file =~ /^\Q$code\E[\w-]*+[.](?i:srt)\z/) {
                        $srt_file = rel2abs($file);
                        last;
                    }
                }
                closedir $dir_h;
            }

            if (not defined $srt_file) {
                system $^X, $CONFIG{gcap}, "http://youtube.com/v/$code";
                if ($? == 0 and not $i++) {
                    redo;
                }
            }
        }
    }

    # Change directory back to the main working directory
    chdir $main_cwd;

    return $srt_file;
}

sub list_category {
    my $iter = $cat_treeview->get_selection->get_selected;
    my $cat_id = $cats_liststore->get($iter, 1) // return;

    my $videos = $yv_obj->get_videos_from_category($cat_id);
    if (@{$videos->{results}}) {
        $liststore->clear if $CONFIG{clear_list};
        print_videos($videos);
    }
    else {
        die "No video found for categoryID: <$cat_id>\n";
    }
}

sub list_tops {
    my $iter = $tops_treeview->get_selection->get_selected;

    my %top_opts;
    $top_opts{feed_id} = $tops_liststore->get($iter, 2) // return;
    my $top_type = $tops_liststore->get($iter, 3);

    if ($top_type ne q{}) {
        $top_opts{time_id} = $top_type;
    }

    if (length(my $region = $gui->get_object('region_entry')->get_text)) {
        $top_opts{region_id} = $region;
    }

    if (length(my $category = $gui->get_object('category_entry')->get_text)) {
        $top_opts{cat_id} = $category;
    }

    $liststore->clear if $CONFIG{clear_list};
    print_videos(
                   $top_type eq 'movies'
                 ? $yv_obj->get_movies($top_opts{feed_id})
                 : $yv_obj->get_video_tops(%top_opts)
                );
}

sub clear_text {
    $_[0]->set_text('') if $CONFIG{clean_text_entries_on_click};
    return 0;
}

sub run_cli_youtube_viewer {
    execute_external_program($CONFIG{terminal}, '-e', q{'} . join(' ', $CONFIG{perl_bin}, $CONFIG{cli_youtube_viewer}), q{'});
}

sub find_terminal {
    foreach my $term (
                      'gnome-terminal', 'lxterminal', 'terminal', 'xfce4-terminal',
                      'sakura',         'lilyterm',   'evilvte',  'superterm',
                      'terminator',     'kterm',      'mlterm',   'mrxvt',
                      'rxvt',           'urxvt',      'uuterm',   'termit',
                      'fbterm',         'stjerm',     'yakuake',  'roxterm'
      ) {
        foreach my $path (path()) {
            if (-e (my $terminal = catfile($path, $term))) {
                return $terminal;
            }
        }
    }
    return $ENV{TERM} || 'xterm';
}

sub get_options_as_arguments {
    my @args;
    my %options = (
                   'non-interactive' => q{},
                   'orderby'         => $CONFIG{orderby},
                   'time'            => $CONFIG{time_sort},
                   'resolution'      => $CONFIG{resolution},
                   'download-dir'    => rel2abs($CONFIG{downloads_folder}),
                   'fullscreen'      => $CONFIG{fullscreen} ? q{} : undef,
                  );

    while (my ($argv, $value) = each %options) {
        push(
            @args,
            do {
                $value             ? '--' . $argv . '=' . $value
                  : defined $value ? '--' . $argv
                  :                  next;
              }
            );
    }
    return @args;
}

sub execute_external_program {
    system join(' ', map { chr ord eq q{'} ? $_ : quotemeta } @_) . ' &';
}

sub _make_youtube_url {

    my $format =
        $CONFIG{search_playlists} ? $CONFIG{playlists_url}
      : $CONFIG{search_channels}  ? $CONFIG{youtube_profile_url}
      :                             $CONFIG{youtube_video_url};

    my $value = $_[0] =~ /^username=(.+)/ ? $1 : shift;

    return sprintf($format, $value);
}

sub open_youtube_url {
    my $url = _make_youtube_url(get_selected_video_code() or return);
    execute_external_program((defined $CONFIG{browser} ? $CONFIG{browser} : 'xdg-open'), $url);
    return 1;
}

my @queue_codes;

sub queue_playback {
    my $code = get_selected_video_code() or return;
    print "[*] Added: <$code>\n" if $yv_obj->get_debug;
    push @queue_codes, $code;
    return 1;
}

sub play_videos_from_queue {
    if (@queue_codes) {
        execute_cli_youtube_viewer('--video-ids=' . join(q{,}, splice @queue_codes));
    }
    return 1;
}

sub play_all_video_results {
    my $model = $treeview->get_model;
    my $iter = $model->get_iter_first // return;

    my @ids;

    do {
        push @ids, $liststore->get($iter, 3);
    } while defined($iter = $model->iter_next($iter));

    execute_cli_youtube_viewer('--video-ids=' . join(q{,}, grep { /$valid_video_id_re/ } @ids));

    return 1;
}

sub play_selected_video_with_cli_youtube_viewer {
    my $code = get_selected_video_code() or return;
    execute_cli_youtube_viewer("--video-id=$code");
    return 1;
}

sub execute_cli_youtube_viewer {
    my @arguments = @_;

    # Executing youtube-viewer
    my $command = join(
                       q{ },
                       (
                        map { chr ord eq q{'} ? $_ : quotemeta } $CONFIG{terminal},
                        '-e',
                        q{'}
                          . join(q{ }, $CONFIG{perl_bin}, $CONFIG{cli_youtube_viewer}, get_options_as_arguments(), @arguments)
                          . q{'}
                       )
                      )
      . ' &';

    say $command if $yv_obj->get_debug;
    system $command;

    warn "youtube-viewer - code exit: $?\n" if $?;

    return 1;
}

sub download_video {
    my $code = get_selected_video_code() or return;
    die "Unable to download a playlist!\n" if $CONFIG{search_playlists};
    execute_cli_youtube_viewer("--video-id=$code", '--download');
    return 1;
}

sub comments_row_activated {
    my $iter = $feeds_treeview->get_selection->get_selected() or return;
    my $value = $feeds_liststore->get($iter, 1);

    if (defined $value and $value =~ m{^https?://}) {
        $feeds_liststore->remove($iter);
        my $comments = $yv_obj->next_page($value, comments => 1);
        if (@{$comments->{results}}) {
            print_comments($comments);
        }
        else {
            die "This is the last page of comments.\n";
        }
    }

    return 1;
}

sub get_user_favorited_videos {
    my $username = get_username_for_selected_video() // return;
    favorited_videos_from_username($username);
}

sub get_username_for_selected_video {
    my $iter = $treeview->get_selection->get_selected() or return;
    return $liststore->get($iter, 6);
}

sub show_related_videos {
    my $code = get_selected_video_code() or return;

    my $videos = $yv_obj->get_related_videos($code);
    if (@{$videos->{results}}) {
        $liststore->clear if $CONFIG{clear_list};
        print_videos($videos);
    }
    else {
        die "No related video for videoID: <$code>\n";
    }
}

sub favorite_video {
    my $code = get_selected_video_code() or return;

    $feeds_statusbar->push(
                           0, $yv_obj->favorite_video($code)
                           ? 'Video favorited.'
                           : 'Error!'
                          );
}

sub subscribe_channel {
    my $user = get_username_for_selected_video();
    $feeds_statusbar->push(
                           0, $yv_obj->subscribe_channel($user)
                           ? "Successfully subscribed to channel: $user."
                           : 'Error!'
                          );
}

sub like_selected_video {
    my $code = get_selected_video_code() or return;
    $feeds_statusbar->push(
                           0, $yv_obj->send_rating_to_video($code, 'like')
                           ? 'Video liked.'
                           : 'Error!'
                          );
}

sub dislike_selected_video {
    my $code = get_selected_video_code() or return;
    $feeds_statusbar->push(
                           0, $yv_obj->send_rating_to_video($code, 'dislike')
                           ? 'Video disliked.'
                           : 'Error!'
                          );
}

sub send_comment_to_video {
    my $videoID = get_selected_video_code() or return;
    my $comment = get_text($gui->get_object('comment_textview'));

    $feeds_statusbar->push(0,
                           length($comment) && $yv_obj->send_comment_to_video($videoID, $comment)
                           ? 'Video comment has been posted!'
                           : 'Error!');
}

sub print_comments {
    my ($results, %options) = @_;

    my $url      = $results->{url};
    my $comments = $results->{results};

    if (not @{$comments}) {
        return;
    }

    my $i = 0;
    foreach my $comment (@{$comments}) {

        my $iter = $feeds_liststore->append;
        $feeds_liststore->set(
                              $iter,
                              0,
                              "<big><b>$comment->{name}</b> ("
                                . format_date($comment->{published})
                                . ") said:</big>\n\t"
                                . encode_entities($comment->{content})
                             );
    }

    my $iter = $feeds_liststore->append;
    $feeds_liststore->set($iter, 0, "\n<big><b>=&gt;&gt; NEXT PAGE</b></big>\n");
    $feeds_liststore->set($iter, 1, $url);
    return 1;
}

sub show_more_videos_from_username {
    videos_from_username(get_username_for_selected_video() or return);
}

sub show_playlists_from_username {
    playlists_from_username(get_username_for_selected_video() or return);
}

# Setting details to details_window
sub set_video_details {
    my ($code, $iter) = @_;
    my $main_details = $liststore->get($iter, 0);

    my %labels = (
                  Added  => 'Published',
                  Length => 'Duration',
                 );

    # Setting title
    my $title = substr($main_details, 0, index($main_details, '</big>') + 6, '');
    $gui->get_object('video_title_label')->set_label("<big>$title</big>");

    # Setting video details
    $main_details =~ s/^\s+//;
    $main_details =~ s{\s*<i>.+</i>\s*}{\n};
    $main_details =~ s/\s+/$-[0] <= 8 ? "\t\t" : "\t"/e;
    if (not $CONFIG{search_channels}) {
        $main_details .= sprintf("<b>AuthorID\t:</b> %s\n", $liststore->get($iter, 6));
    }

    my $secondary_details = $liststore->get($iter, 2);
    $secondary_details =~ s/:(?!\d)/\t: /g;
    $secondary_details =~ s/\b$_\b\t/$labels{$_}/ for keys %labels;
    $gui->get_object('video_details_label')->set_label($main_details . $secondary_details);

    # Setting the link button
    my $url        = _make_youtube_url($code);
    my $linkbutton = $gui->get_object('linkbutton1');
    $linkbutton->set_label($url);
    $linkbutton->set_uri($url);

    # Getting thumbs
    foreach my $nr (qw(1 2 3)) {
        if ($CONFIG{search_playlists} or $CONFIG{search_channels}) {
            $gui->get_object("image$nr")->set_from_pixbuf($default_thumb);
        }
        else {
            my $pixbuf = _get_pixbuf_thumbnail(sprintf($CONFIG{thumb_url}, $code, $nr));
            $gui->get_object("image$nr")->set_from_pixbuf($pixbuf);
        }
    }

    # Setting textview description
    set_text($gui->get_object('description_textview'), $liststore->get($iter, 4));
    return 1;
}

sub on_mainw_destroy {

    # Save hpaned position
    $CONFIG{hpaned_position} = $hbox2->get_position;

    get_main_window_size();
    dump_configuration();
    save_usernames_to_file();
    'Gtk2'->main_quit;
    exit 0;
}

$notebook->set_current_page($CONFIG{default_notebook_page});

'Gtk2'->main;
