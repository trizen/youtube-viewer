#!/usr/bin/perl

# Copyright (C) 2010-2024 Trizen <echo dHJpemVuQHByb3Rvbm1haWwuY29tCg== | base64 -d>.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of either: the GNU General Public License as published
# by the Free Software Foundation; or the Artistic License.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
#
# See https://dev.perl.org/licenses/ for more information.
#
#-------------------------------------------------------
#  youtube-viewer
#  Created on: 02 June 2010
#  Latest edit on: 11 August 2024
#  https://github.com/trizen/youtube-viewer
#-------------------------------------------------------

# youtube-viewer is a command line utility for streaming YouTube videos in mpv/vlc.

# Many thanks to everyone who contributed in making this application:
#   https://github.com/trizen/youtube-viewer/graphs/contributors

# Special thanks to:
# - Army (for the bug reports and for his great ideas: https://aur.archlinux.org/packages.php?ID=37779&comments=all)
# - dhn (for adding youtube-viewer in freshports.org: https://www.freshports.org/multimedia/youtube-viewer)
# - stressat (for the great review of youtube-viewer: https://stressat.blogspot.com/2012/01/youtube-viewer.html)
# - symbianflo (for packaging youtube-viewer for Mandriva: https://abf.rosalinux.ru/symbianflo/youtube-viewer)
# - gotbletu (for the great video review of youtube-viewer: https://www.youtube.com/watch?v=FnJ67oAxVQ4)
# - Julian Ospald (for adding youtube-viewer in the gentoo portage tree: https://packages.gentoo.org/package/net-misc/youtube-viewer)
# - 666philb (for packaging gtk-youtube-viewer for Puppy Linux: https://www.murga-linux.com/puppy/viewtopic.php?t=76835)
# - Kevin Lemonnier (for adding proxy support - https://github.com/trizen/youtube-viewer/pull/18)
# - Georgo (for adding the 'Watch Later' feature - https://github.com/trizen/youtube-viewer/pull/44)
# - Daniel Wallace (for adding youtube-viewer in the Arch Official Community repository - https://www.archlinux.org/packages/community/any/youtube-viewer/)
# - NTmatter (for adding reverse range support - https://github.com/trizen/youtube-viewer/pull/2)
# - Andrew (for a nice review of (gtk-)youtube-viewer: https://www.webupd8.org/2015/02/youtube-viewer-complete-youtube-client.html)
# - AnyComputer (for a complete french review of gtk-youtube-viewer: https://www.youtube.com/watch?v=6-qbdDUlBqg)
# - Jookia (for fixing the proxy system and improving the support for encrypted videos - https://github.com/Jookia)

=encoding utf8

=head1 NAME

youtube-viewer - YouTube from command line.

See: youtube-viewer --help
     youtube-viewer --tricks
     youtube-viewer --examples
     youtube-viewer --stdin-help

=cut

use utf8;
use 5.016;

use warnings;
no warnings 'once';

use Term::ReadLine        qw();
use File::Spec::Functions qw(
  catdir
  catfile
  curdir
  path
  rel2abs
  splitdir
  file_name_is_absolute
);

my $DEVEL;
BEGIN { $DEVEL = -w __FILE__ }

sub devel_path {
    require FindBin;
    my @dirs = splitdir($FindBin::RealBin);
    pop(@dirs);
    return @dirs;
}

use if $DEVEL, lib => $DEVEL && catdir(devel_path(), 'lib');

use WWW::YoutubeViewer v3.11.2;
use WWW::YoutubeViewer::RegularExpressions;

binmode(STDOUT, ':utf8');

my $appname  = 'YouTube Viewer';
my $version  = $WWW::YoutubeViewer::VERSION;
my $execname = 'youtube-viewer';

# A better <STDIN> support:
my $term = Term::ReadLine->new("$appname $version");

sub VIDEO_PART () { 'contentDetails,statistics,snippet' }

# Options (key=>value) goes here
my %opt;
my $term_width = 80;

# Keep track of watched videos by their ID
my %WATCHED_VIDEOS;

# Unchangeable data goes here
my %constant = (
                win32   => (lc($^O) eq 'mswin32' ? 1 : 0),
                android => (lc($^O) eq 'android' ? 1 : 0),
               );

my $home_dir;
my $xdg_config_home = $ENV{XDG_CONFIG_HOME};

if ($xdg_config_home and -d $xdg_config_home) {
    require File::Basename;
    $home_dir = File::Basename::dirname($xdg_config_home);

    if (not -d $home_dir) {
        $home_dir = $ENV{HOME} || curdir();
    }
}
else {
    $home_dir =
         $ENV{HOME}
      || $ENV{LOGDIR}
      || ($constant{win32} ? '\Local Settings\Application Data' : ((getpwuid($<))[7] || `echo -n ~`));

    if (not -d $home_dir) {
        $home_dir = curdir();
    }

    $xdg_config_home = catdir($home_dir, '.config');
}

# Configuration dirs
my $config_dir          = catdir($xdg_config_home, $execname);
my $local_playlists_dir = catdir($config_dir,      'playlists');

# Configuration files
my $config_file         = catfile($config_dir, "$execname.conf");
my $youtube_users_file  = catfile($config_dir, 'youtube_users.txt');
my $authentication_file = catfile($config_dir, 'reg.dat');
my $history_file        = catfile($config_dir, 'cli-history.txt');
my $api_file            = catfile($config_dir, 'api.json');

# Special local playlists
my $saved_videos_file  = catfile($local_playlists_dir, "saved_videos.txt");
my $watch_history_file = catfile($local_playlists_dir, 'watched_videos.txt');

# Local subscriptions files
my $local_subscriptions_data_file  = catfile($config_dir,          "subscriptions.dat");
my $local_subscription_videos_file = catfile($local_playlists_dir, "local_subscription_videos.txt");

# Default path to api.json
my $default_api_file = '/etc/youtube-viewer/api.json';

foreach my $dir ($config_dir, $local_playlists_dir) {
    if (not -d $dir) {
        require File::Path;
        eval { File::Path::make_path($dir) }
          or warn "[!] Can't create dir <<$dir>>: $!";
    }
}

sub which_command {
    my ($cmd) = @_;

    if (file_name_is_absolute($cmd)) {
        return $cmd;
    }

    state $paths = [path()];
    foreach my $path (@{$paths}) {
        my $cmd_path = catfile($path, $cmd);
        if (-f -x $cmd_path) {
            return $cmd_path;
        }
    }

    return;
}

# Main configuration
my %CONFIG = (

    video_players => {

        (
         $constant{android}
         ? (
            vlc => {
                    arg     => "start -n org.videolan.vlc/org.videolan.vlc.gui.video.VideoPlayerActivity -a android.intent.action.VIEW -d *VIDEO*",
                    cmd     => "am",
                    fs      => "",
                    novideo => "",
                    srt     => "",
                   }
           )
         : (
            vlc => {
                    cmd     => q{vlc},
                    srt     => q{--sub-file=*SUB*},
                    audio   => q{--input-slave=*AUDIO*},
                    fs      => q{--fullscreen},
                    arg     => q{--quiet --play-and-exit --no-video-title-show --input-title-format=*TITLE* *VIDEO*},
                    novideo => q{--intf=dummy --novideo},
                   }
           )
        ),

        mpv => {
                cmd     => q{mpv},
                srt     => q{--sub-file=*SUB*},
                audio   => q{--audio-file=*AUDIO*},
                fs      => q{--fullscreen},
                arg     => q{--really-quiet --force-media-title=*TITLE* --no-ytdl *VIDEO*},
                novideo => q{--no-video},
               },

        mpvraw => {
                   arg     => q{--ytdl-raw-options-append="format-sort=ext,res:*RESOLUTION*" *URL*},
                   cmd     => q{mpv},
                   fs      => q{--fullscreen},
                   novideo => q{--no-video},
                   srt     => q{--sub-file=*SUB*},
                  },
    },

    video_player_selected => (
        ($constant{win32} || $constant{android})
        ? 'vlc'
        : undef    # auto-defined
    ),

    # YouTube options
    split_videos    => $constant{android} ^ 1,
    dash_segmented  => 1,                        # may load slow
    maxResults      => 20,
    hfr             => 1,
    resolution      => 'best',
    audio_quality   => 'best',
    videoDefinition => undef,
    videoDimension  => undef,
    videoLicense    => undef,
    safeSearch      => undef,
    videoCaption    => undef,
    videoDuration   => undef,
    videoSyndicated => undef,
    publishedBefore => undef,
    publishedAfter  => undef,
    order           => undef,

    comments_order      => 'time',         # valid values: time, relevance
    subscriptions_order => 'relevance',    # valid values: alphabetical, relevance, unread

    hl         => 'en_US',
    regionCode => undef,

    # URI options
    youtube_video_url => 'https://www.youtube.com/watch?v=%s',

    # Subtitle options
    srt_languages => ['en', 'es'],
    get_captions  => 1,
    auto_captions => 0,
    copy_caption  => 0,
    cache_dir     => undef,          # auto-defined

    # Misc options
    autoplay_mode      => 0,
    http_proxy         => undef,
    cookie_file        => undef,
    user_agent         => undef,
    timeout            => undef,
    env_proxy          => 1,
    confirm            => 0,
    debug              => 0,
    page               => 1,
    colors             => $constant{win32} ^ 1,
    skip_if_exists     => 1,
    prefer_mp4         => 0,
    prefer_m4a         => 0,
    prefer_av1         => 0,
    ignore_av1         => 0,
    force_fallback     => 0,
    fat32safe          => $constant{win32},
    fullscreen         => 0,
    show_video_info    => 1,
    interactive        => 1,
    get_term_width     => $constant{win32} ^ 1,
    download_with_wget => undef,                  # auto-defined
    download_with_ytdl => undef,                  # auto-defined
    thousand_separator => q{,},
    downloads_dir      => curdir(),
    download_and_play  => 0,
    youtube_users_file => $youtube_users_file,
    remove_played_file => 0,

    subscription_videos_per_channel => 20,

    bypass_age_gate_native     => 0,
    bypass_age_gate_with_proxy => 0,
    ignored_projections        => [],

    video_min_seconds => 0,

    # Conversion options
    convert_cmd         => 'ffmpeg -i *IN* *OUT*',
    convert_to          => undef,
    keep_original_video => 0,

    # Search history
    history       => undef,           # auto-defined
    history_limit => 100_000,
    history_file  => $history_file,

    # Watch history
    watch_history      => 1,
    watch_history_file => $watch_history_file,

    # Saved videos
    saved_videos_file => $saved_videos_file,

    # Options for watched videos
    highlight_watched => 1,
    highlight_color   => 'bold',
    skip_watched      => 0,
    autolike_watched  => 0,

    # yt-dlp / youtube-dl support
    ytdl     => 1,
    ytdl_cmd => undef,    # auto-defined

    # Custom layout
    custom_layout_format => [{width => 3,     align => "right", color => "bold",      text => "*NO*.",},
                             {width => "55%", align => "left",  color => "bold blue", text => "*TITLE*",},
                             {width => "15%", align => "left",  color => "magenta",   text => "*AUTHOR*",},
                             {width => 3,     align => "right", color => "green",     text => "*AGE_SHORT*",},
                             {width => 5,     align => "right", color => "green",     text => "*VIEWS_SHORT*",},
                             {width => 8,     align => "right", color => "blue",      text => "*TIME*",},
                            ],

    custom_channel_layout_format => [{width => 3,     align => "right", color => "bold",      text => "*NO*.",},
                                     {width => "55%", align => "left",  color => "bold blue", text => "*TITLE*",},
                                     {width => 3,     align => "right", color => "yellow",    text => "*AGE_SHORT*",},
                                     {width => 14,    align => "right", color => "magenta",   text => "*VIDEOS* videos",},
                                     {width => 10,    align => "right", color => "green",     text => "*SUBS_SHORT* subs",},
                                    ],

    custom_playlist_layout_format => [{align => "right", color => "bold",      text => "*NO*.",          width => 3},
                                      {align => "left",  color => "bold blue", text => "*TITLE*",        width => "55%"},
                                      {align => "right", color => "green",     text => "*ITEMS* videos", width => 14},
                                      {align => "left",  color => "magenta",   text => "*AUTHOR*",       width => "20%"},
                                     ],

    ffmpeg_cmd => 'ffmpeg',
    wget_cmd   => 'wget',

    merge_into_mkv      => undef,                                                                    # auto-defined later
    merge_into_mkv_args => '-loglevel warning -c:s srt -c:v copy -c:a copy -disposition:s forced',
    merge_with_captions => 1,

    video_filename_format => '*FTITLE* - *ID*.*FORMAT*',
);

local $SIG{__WARN__} = sub { warn @_; ++$opt{_error} };

my %PLAYER_ARGS;    # will store video player arguments

my $base_options = <<'BASE';
# Base
[keywords]        : search for YouTube videos
[youtube-url]     : play a video by YouTube URL
:v(ideoid)=ID     : play videos by YouTube video IDs
[playlist-url]    : display videos from a playlistURL
:playlist=ID      : display videos from a playlistID
BASE

my $action_options = <<'ACTIONS';
# Actions
:login            : will prompt you for login
:logout           : will delete the authentication key
ACTIONS

my $control_options = <<'CONTROL';
# Control
:n(ext)           : get the next page of results
:b(ack)           : get the previous page of results
CONTROL

my $other_options = <<'OTHER';
# Others
:r(eturn)         : return to previous page of results
:refresh          : refresh the current list of results
:dv=i             : display the data structure of result i
-argv -argv2=v    : apply some arguments (e.g.: -u=google)
:reset, :reload   : restart the application
:q, :quit, :exit  : close the application
OTHER

my $notes_options = <<'NOTES';
NOTES:
 1. You can specify more options in a row, separated by spaces.
 2. A stdin option is valid only if it begins with '=', ';' or ':'.
 3. Quoting a group of space separated keywords or option-values,
    the group will be considered a single keyword or a single value.
NOTES

my $general_help = <<"HELP";

$action_options
$control_options
$other_options
$notes_options
Examples:
     3                  : select the 3rd result
    -sv funny cats      : search for videos
    -sc mathematics     : search for channels
    -sp classical music : search for playlists
HELP

my $playlists_help = <<"PLAYLISTS_HELP" . $general_help;

# Select a playlist
<number>          : list videos from the selected playlist
:p=i              : list playlists from the selected author
:pp=i,i           : play videos from the selected playlists

# Save and remove playlists
:s=i :save=i      : save the playlist locally (see -lp)
:r=i :remove=i    : remove a locally saved playlist from -lp
PLAYLISTS_HELP

my $channels_help = <<"CHANNELS_HELP" . $general_help;

# Select a channel
<number>           : latest uploads from channel
:pv=i :popular=i   : popular uploads from channel
:p=i  :playlists=i : playlists from channel

# Save and remove channels
:s=i  :save=i      : save the channel ID locally (see -lc)
:r=i  :remove=i,i  : remove the selected channels from file

# Subscribe and unsubscribe from channels
:sub=i             : subscribe to channel
:unsub=i           : unsubscribe from channel
CHANNELS_HELP

my $comments_help = <<"COMMENTS_HELP" . $general_help;

# Comments
:c(omment)        : send a comment to this video
COMMENTS_HELP

my $complete_help = <<"STDIN_HELP";

$base_options
$control_options
$action_options
# YouTube
:i(nfo)=i,i       : display more information
:d(ownload)=i,i   : download the selected videos
:c(omments)=i     : display video comments
:r(elated)=i      : display related videos
:u(ploads)=i      : display author's latest uploads
:pv=i :popular=i  : display author's popular uploads
:A(ctivity)=i     : display author's recent activity
:p(laylists)=i    : display author's playlists
:s=i  :save=i     : save a video ID in a local playlist (see -lp)
:rm=i :remove=i,i : remove a saved video from the local playlist
:sc=i             : save author's channel ID to file (see -lc)
:ps=i :s2p=i,i    : save videos to a post-selected playlist
:sub(scribe)=i    : subscribe to author's channel
:unsub(scribe)=i  : unsubscribe from author's channel
:w=i  :mark=i     : add video to watched history
:(dis)like=i      : like or dislike a video
:fav(orite)=i     : favorite a video
:autoplay=i       : autoplay mode, starting from video i
:page=i           : jump to page i of results
:beg :end         : jump to first or last page of results

# Playing
<number>          : play the corresponding video
3-8, 3..8         : same as 3 4 5 6 7 8
8-3, 8..3         : same as 8 7 6 5 4 3
8 2 12 4 6 5 1    : play the videos in a specific order
10..              : play all the videos onwards from 10
:q(ueue)=i,i,...  : enqueue videos for playing them later
:pq, :play-queue  : play the enqueued videos (if any)
:anp, :nnp        : auto-next-page, no-next-page
:play=i,i,...     : play a group of selected videos
:regex='RE'       : play videos matched by a regex (/i)
:kregex=KEY,RE    : play videos if the value of KEY matches the RE

$other_options
$notes_options
** Examples:
:regex='\\w \\d' -> play videos matched by a regular expression.
:info=1        -> show extra information for the first video.
:d18-20,1,2    -> download the selected videos: 18, 19, 20, 1 and 2.
3 4 :next 9    -> play the 3rd and 4th videos from the current
                  page, go to the next page and play the 9th video.
STDIN_HELP

{
    my $config_documentation = <<"EOD";
#!/usr/bin/perl

# $appname $version - configuration file

use utf8;

EOD

    sub dump_configuration {
        my ($config_file) = @_;

        require Data::Dump;
        open my $config_fh, '>', $config_file
          or do { warn "[!] Can't open '${config_file}' for write: $!"; return };

        my $dumped_config = q{our $CONFIG = } . Data::Dump::pp(\%CONFIG) . "\n";

        if (defined($ENV{HOME}) and $home_dir eq $ENV{HOME}) {
            $dumped_config =~ s/\Q$home_dir\E/\$ENV{HOME}/g;
        }

        print $config_fh $config_documentation, $dumped_config;
        close $config_fh;
    }
}

our $CONFIG;

sub load_config {
    my ($config_file) = @_;

    if (not -e $config_file or -z _ or $opt{reconfigure}) {
        dump_configuration($config_file);
    }

    require $config_file;    # Load the configuration file

    if (ref $CONFIG ne 'HASH') {
        die "[ERROR] Invalid configuration file!\n\t\$CONFIG is not an HASH ref!";
    }

    # Get valid config keys
    my @valid_keys = grep { exists $CONFIG{$_} } keys %{$CONFIG};
    @CONFIG{@valid_keys} = @{$CONFIG}{@valid_keys};

    my $update_config = 0;

    # Define the cache directory
    if (not defined $CONFIG{cache_dir}) {

        my $cache_dir =
          ($ENV{XDG_CACHE_HOME} and -d $ENV{XDG_CACHE_HOME})
          ? $ENV{XDG_CACHE_HOME}
          : catdir($home_dir, '.cache');

        if (not -d $cache_dir) {
            $cache_dir = catdir(curdir(), '.cache');
        }

        $CONFIG{cache_dir} = catdir($cache_dir, 'youtube-viewer');
        $update_config = 1;
    }

    # Locate video player
    if (not $CONFIG{video_player_selected}) {

        foreach my $key (sort keys %{$CONFIG{video_players}}) {
            if (defined(my $abs_player_path = which_command($CONFIG{video_players}{$key}{cmd}))) {
                $CONFIG{video_players}{$key}{cmd} = $abs_player_path;
                $CONFIG{video_player_selected}    = $key;
                $update_config                    = 1;
                last;
            }
        }

        if (not $CONFIG{video_player_selected}) {
            warn "\n[!] Please install a supported video player! (e.g.: mpv)\n\n";
            $CONFIG{video_player_selected} = 'mpv';
        }
    }

    # Locate yt-dlp or youtube-dl (in this order)
    if (   not defined($CONFIG{ytdl_cmd})
        or not defined($CONFIG{download_with_ytdl})) {

        foreach my $ytdl (qw(yt-dlp youtube-dl)) {
            my $ytdl_path = which_command($ytdl);

            if (defined($ytdl_path)) {
                $CONFIG{ytdl_cmd} = $ytdl_path;
                $CONFIG{download_with_ytdl} //= 1;
                last;
            }
        }

        $CONFIG{ytdl_cmd}           //= 'yt-dlp';
        $CONFIG{download_with_ytdl} //= 0;
        $update_config = 1;
    }

    # Download with wget if it is installed
    if (not defined $CONFIG{download_with_wget}) {

        my $wget_path = which_command('wget');

        if (defined($wget_path)) {
            $CONFIG{wget_cmd}           = $wget_path;
            $CONFIG{download_with_wget} = 1;
        }
        else {
            $CONFIG{download_with_wget} = 0;
        }

        $update_config = 1;
    }

    # Merge into MKV if ffmpeg is installed
    if (not defined $CONFIG{merge_into_mkv}) {

        my $ffmpeg_path = which_command('ffmpeg');

        if (defined($ffmpeg_path)) {
            $CONFIG{ffmpeg_cmd}     = $ffmpeg_path;
            $CONFIG{merge_into_mkv} = 1;
        }
        else {
            $CONFIG{merge_into_mkv} = 0;
        }

        $update_config = 1;
    }

    # Enable history if Term::ReadLine::Gnu::XS is installed
    if (not defined $CONFIG{history}) {

        if (eval { $term->can('ReadHistory') }) {
            $CONFIG{history} = 1;
        }
        else {
            $CONFIG{history} = 0;
        }

        $update_config = 1;
    }

    foreach my $key (keys %CONFIG) {
        if (not exists $CONFIG->{$key}) {
            $update_config = 1;
            last;
        }
    }

    dump_configuration($config_file) if $update_config;

    # Create the cache directory (if needed)
    foreach my $path ($CONFIG{cache_dir}) {
        next if -d $path;
        require File::Path;
        eval { File::Path::make_path($path) }
          or warn "[!] Can't create path <<$path>>: $!";
    }

    @opt{keys %CONFIG} = values(%CONFIG);
}

load_config($config_file);

if ($opt{watch_history}) {
    if (-f $opt{watch_history_file}) {
        if (open my $fh, '<', $opt{watch_history_file}) {
            chomp(my @ids = <$fh>);
            @WATCHED_VIDEOS{@ids} = ();
            close $fh;
        }
        else {
            warn "[!] Can't open the watched file `$opt{watch_history_file}' for reading: $!";
        }
    }
}

if ($opt{history}) {

    # Create the history file.
    if (not -e $opt{history_file}) {

        require File::Basename;
        my $dir = File::Basename::dirname($opt{history_file});

        if (not -d $dir) {
            require File::Path;
            eval { File::Path::make_path($dir) }
              or warn "[!] Can't create path <<$dir>>: $!";
        }

        open my $fh, '>', $opt{history_file}
          or warn "[!] Can't create the history file `$opt{history_file}': $!";
    }

    # Add history to Term::ReadLine
    eval { $term->ReadHistory($opt{history_file}) };

    # All history entries
    my @history;
    eval { @history = $term->history_list };

    # Rewrite the history file, when the history_limit has been reached.
    if ($opt{history_limit} > 0 and @history > $opt{history_limit}) {

        # Try to create a backup, first
        require File::Copy;
        File::Copy::cp($opt{history_file}, "$opt{history_file}.bak");

        if (open my $fh, '>', $opt{history_file}) {

            # Keep only the most recent half part of the history file
            say {$fh} join("\n", @history[($opt{history_limit} >> 1) .. $#history]);
            close $fh;
        }
    }
}

my $yv_obj = WWW::YoutubeViewer->new(
                                     escape_utf8         => 1,
                                     config_dir          => $config_dir,
                                     cache_dir           => $opt{cache_dir},
                                     env_proxy           => $opt{env_proxy},
                                     cookie_file         => $opt{cookie_file},
                                     http_proxy          => $opt{http_proxy},
                                     user_agent          => $opt{user_agent},
                                     timeout             => $opt{timeout},
                                     authentication_file => $authentication_file,
                                    );

if (-f $default_api_file) {
    $yv_obj->load_credentials($default_api_file);
}

if (-f $api_file) {
    $yv_obj->load_credentials($api_file);
}
else {
    open(my $fh, '>', $api_file) or warn "[!] Can't create file <<$api_file>>: $!\n";
    print $fh <<"EOT";
{
    "key":           "API_KEY",
    "client_id":     "CLIENT_ID",
    "client_secret": "CLIENT_SECRET"
}
EOT
    close $fh;
}

if (not defined $yv_obj->get_key) {
    warn join("\n",
              "\nError: no API key has been set!\n\nFor creating/setting an YouTube API key, please see:",
              "https://github.com/trizen/youtube-viewer#logging-in\n\n");
}

$yv_obj->load_authentication_tokens();

require WWW::YoutubeViewer::Utils;
my $yv_utils = WWW::YoutubeViewer::Utils->new(youtube_url_format => $opt{youtube_video_url},
                                              thousand_separator => $opt{thousand_separator},);

{    # Apply the configuration file
    my %temp = %CONFIG;
    apply_configuration(\%temp);
}

#---------------------- YOUTUBE-VIEWER USAGE ----------------------#
sub help {
    my $eqs = q{=} x 30;

    local $" = ', ';
    print <<"HELP";
\n  $eqs \U$appname\E $eqs

usage: $execname [options] ([url] | [keywords])

== Base ==
   [URL]             : play an YouTube video by URL
   [keywords]        : search for YouTube videos
   [playlist URL]    : display a playlist of YouTube videos


== YouTube Options ==

 * Categories
   -c  --categories     : display the available YouTube categories
   -hl --catlang=s      : language for categories (default: en_US)

 * Region
   --region=s           : set the region code (default: US)

 * Videos
   -uv --uploads=s      : list videos uploaded by a specific channel or user
   -pv --popular=s      : list the most popular videos from a specific channel
   -uf --favorites=s    : list the favorite videos of a specific user
   -id --videoids=s,s   : play YouTube videos by their IDs
   -rv --related=s      : show related videos for a video ID or URL
   -sv --search-videos  : search for YouTube videos (default mode)
   -wv --watched-videos : list the most recent watched videos
       --save-video=s   : save a video in a local playlist by video ID or URL
   -lv --local-videos   : display the local playlist of saved videos
   -ls --local-subs     : display subscription videos from local channels

 * Playlists
   -up --playlists=s      : list playlists created by a specific channel or user
   -sp --search-pl        : search for playlists of videos
       --pid=s            : list a playlist of videos by playlist ID
       --pp=s,s           : play the videos from the given playlist IDs
       --ps=s             : add video by ID or URL to a post-selected playlist
                            or in a given playlist ID specified with `--pid`
       --position=i       : position in the playlist where to add the video
       --save-playlist=s  : save a playlist locally given a playlist ID
   -lp --local-playlists  : display saved local playlists
   -lp=s                  : display a local playlist by name

* Activities
   -ua --activities:s : show activity events for a given channel

* Trending
   --trending:s       : show trending videos in a given category ID or name
                        use "--region=XX" to change the region

 * Channels
   -sc --channels         : search for YouTube channels
       --save-channel=s   : save a channel locally given a channel ID
   -lc --local-channels   : display the list of local channels
   -lc=s                  : display videos from a local channel by name


* Comments
   --comments=s         : display comments for a video by ID or URL
   --comments-order=s   : change the order of YouTube comments
                          valid values: relevance, time

 * Filtering
   --author=s           : search in videos uploaded by a specific user
   --duration=s         : set video duration (short, medium, long, any)
   --caption=s          : set video caption (any, closedCaption, none)
   --safe-search=s      : set safe search (strict, moderate, none)
   --order=s            : order the results using a specific sorting method
                          valid values: date rating viewCount title videoCount
   --within=s           : show only videos uploaded within the specified time
                          valid values: any, Nd, Nw, Nm, Ny, where N is a number
   --before=s           : the opposite of --within
   --hd!                : search only for videos available in at least 720p
   --vd=s               : set the video definition (any, high, standard)
   --dimension=s        : set video dimension (2d, 3d, any)
   --license=s          : set video license (any, creativeCommon, youtube)
   --category=s         : search only for videos in a specific category name/ID
   --page=i             : get results starting with a specific page number
   --results=i          : how many results to display per page (max: 50)
   --hfr!               : prefer high frame rate (HFR) videos
   -2  -3  -4  -7  -1   : resolutions: 240p, 360p, 480p, 720p and 1080p
   -a  --audio          : prefer audio part only (implied by --novideo)
   --best               : prefer best resolution available
   --resolution=s       : supported resolutions: best, 2160p, 1440p,
                          1080p, 720p, 480p, 360p, 240p, 144p, audio.

 * Account
   --login              : will prompt for authentication (OAuth 2.0)
   --logout             : will delete the authentication key

 * [GET] Personal
   -U  --uploads:s       : show the uploads from your channel *
   -P  --playlists:s     : show the playlists from your channel *
   -F  --favorites:s     : show the latest favorite videos *
   -S  --subscriptions:s : show the subscribed channels *
   -SV --subs-videos:s   : show the subscription videos (slow) *
       --subs-order=s    : change the subscription order
                           valid values: alphabetical, relevance, unread
   -L  --likes           : show the videos that you liked on YouTube *
       --dislikes        : show the videos that you disliked on YouTube *

* [POST] Personal
   --subscribe=s        : subscribe to a given channel ID or username *
   --unsubscribe=s      : unsubscribe from a given channel ID or username *
   --favorite=s         : favorite a video by URL or ID *
   --like=s             : send a 'like' rating to a video URL or ID *
   --dislike=s          : send a 'dislike' rating to a video URL or ID *


== Player Options ==

 * Arguments
   -f  --fullscreen!  : play videos in fullscreen mode
   -n  --novideo      : play audio only, without displaying video
   --append-arg=s     : append some command-line parameters to the media player
   --player=s         : select a player to stream videos
                        available players: @{[keys %{$CONFIG->{video_players}}]}


== Download Options ==

 * Download
   -d  --download!       : activate the download mode
   -dp --dl-play!        : play the video after download (with -d)
   -rp --rem-played!     : delete a local video after played (with -dp)
       --wget-dl!        : download videos with wget (recommended)
       --skip-if-exists! : don't download videos which already exist (with -d)
       --copy-caption!   : copy and rename the caption for downloaded videos
       --downloads-dir=s : downloads directory (set: '$opt{downloads_dir}')
       --filename=s      : set a custom format for the video filename (see: -T)
       --fat32safe!      : makes filenames FAT32 safe
       --mkv-merge!      : merge audio and video into an MKV container
       --merge-captions! : include closed-captions in the MKV container

 * Convert
   --convert-cmd=s      : command for converting videos after download
                          which include the *IN* and *OUT* tokens
   --convert-to=s       : convert video to a specific format (with -d)
   --keep-original!     : keep the original video after converting


== Other Options ==

 * Behavior
   -A  --all!            : play the video results in order
   -B  --backwards!      : play the video results in reverse order
   -s  --shuffle!        : shuffle the results of videos
   -I  --interactive!    : interactive mode, prompting for user input
       --autoplay!       : autoplay mode, automatically playing related videos
       --std-input=s     : use this value as the first standard input
       --max-seconds=i   : ignore videos longer than i seconds
       --min-seconds=i   : ignore videos shorter than i seconds
       --get-term-width! : allow $execname to read your terminal width
       --skip-watched!   : don't play already watched videos
       --highlight!      : remember and highlight watched videos
       --autolike!       : automatically like videos after watching them
       --confirm!        : show a confirmation message after each play
       --prefer-mp4!     : prefer videos in MP4 format, instead of VP9
       --prefer-av1!     : prefer videos in AV1 format, instead of VP9
       --prefer-m4a!     : prefer audios in AAC format, instead of OPUS
       --ignore-av1!     : ignore videos in AV1 format
       --audio-quality=s : audio quality: best, medium or low
       --force-fallback! : extract streaming URLs using the fallback method

 * Closed-captions
   --get-captions!      : download closed-captions for videos
   --auto-captions!     : include or exclude auto-generated captions
   --srt-languages=s    : comma separated list of preferred languages

 * Config
   --config=s           : configuration file
   --update-config!     : update the configuration file

 * Output
   -i  --info=s         : show information for a video ID or URL
   -e  --extract=s      : extract information from videos (see: -T)
       --extract-file=s : extract information from videos in this file
       --dump=format    : dump metadata information in `videoID.format` files
                          valid formats: json, perl
   -q  --quiet          : do not display any warning
       --really-quiet   : do not display any warning or output
       --video-info!    : show video information before playing
       --escape-info!   : quotemeta() the fields of the `--extract`
       --use-colors!    : enable or disable the ANSI colors for text

* Formatting
    --custom-layout=s          : custom layout format for videos
    --custom-channel-layout=s  : custom layout format for channels
    --custom-playlist-layout=s : custom layout format for playlists

 * Other
   --cookies=s          : file to read cookies from and dump cookie
   --user-agent=s       : specify a custom user agent
   --proxy=s            : set HTTP(S)/SOCKS proxy: 'proto://domain.tld:port/'
                          If authentication is required,
                          use 'proto://user:pass\@domain.tld:port/'
   --split-videos!      : include or exclude videos with split A/V files
   --dash-segmented!    : include or exclude segmented DASH streams
   --ytdl!              : use youtube-dl for videos with encrypted signatures
                          `--no-ytdl` will use invidious instances
   --ytdl-cmd=s         : youtube-dl command (default: youtube-dl)

Help options:
   -T  --tricks         : show more 'hidden' features of $execname
   -E  --examples       : show several usage examples of $execname
   -H  --stdin-help     : show the valid stdin options for $execname
   -v  --version        : print version and exit
   -h  --help           : print help and exit
       --debug:1..3     : see behind the scenes

NOTES:
    *    -> requires authentication
    !    -> the argument can be negated with '--no-'
    =i   -> requires an integer argument
    =s   -> requires an argument
    :s   -> can take an optional argument
    =s,s -> can take more arguments separated by commas

HELP
    main_quit(0);
}

sub wrap_text {
    my (%args) = @_;

    require Text::Wrap;
    local $Text::Wrap::columns = ($args{columns} || $term_width) - 8;

    my $text = "@{$args{text}}";
    $text =~ tr{\r}{}d;

    return eval { Text::Wrap::wrap($args{i_tab}, $args{s_tab}, $text) } // $text;
}

sub tricks {
    print <<"TRICKS";

                == youtube-viewer -- tips and tricks ==

-> Playing videos
 > To stream the videos in other players, you need to change the
   configuration file. Where it says "video_player_selected", change it
   to any player which is defined inside the "video_players" hash.

-> Arguments
 > Almost all boolean arguments can be negated with a "--no-" prefix.
 > Arguments that require an ID/URL, you can specify more than one,
   separated by whitespace (quoted), or separated by commas.

-> My channel
 > By using the string "mine" where a channel ID is required, "mine" will be
   automatically replaced with your channel ID. (requires authentication)

   Examples:
        $execname --uploads=mine
        $execname --likes=mine
        $execname --favorites=mine
        $execname --playlists=mine

-> More STDIN help:
 > ":r", ":return" will return to the previous page of results.
   For example, if you search for playlists, then select a playlist
   of videos, inserting ":r" will return back to the playlist results.
   Also, for the previous page, you can insert ':b', but ':r' is faster!

 > "6" (quoted) will search for videos with the keyword '6'.

 > If a stdin option is followed by one or more digits, the equal sign,
   which separates the option from value, can be omitted.

   Example:
        :i2,4  is equivalent with :i=2,4
        :d1-5  is equivalent with :d=1,2,3,4,5
        :c10   is equivalent with :c=10

 > When more videos are selected to play, you can stop them by
   pressing CTRL+C. $execname will return to the previous section.

 > Space inside the values of STDIN options, can be either quoted
   or backslashed.

   Example:
        :re=video\\ title     ==     :re="video title"

 > ":anp" stands for "Auto Next Page". How do we use it?
   Well, let's search for some videos. Now, if we want to play
   only the videos matched by a regex, we'd say :re='REGEX'.
   But, what if we want to play the videos from the next pages too?
   In this case, ":anp" is your friend. Use it wisely!

-> Special tokens:

  *ID*           : the YouTube video ID
  *AUTHOR*       : the author name of the video
  *CHANNELID*    : the channel ID of the video
  *RESOLUTION*   : the resolution of the video
  *VIEWS*        : the number of views
  *VIEWS_SHORT*  : the number of views in abbreviated notation
  *VIDEOS*       : the number of channel videos
  *VIDEOS_SHORT* : the number of channel videos in abbreviated notation
  *SUBS*         : the number of channel subscriptions
  *SUBS_SHORT*   : the number of channel subscriptions in abbreviated notation
  *ITEMS*        : the number of playlist items
  *ITEMS_SHORT*  : the number of playlist items in abbreviated notation
  *LIKES*        : the number of likes
  *DISLIKES*     : the number of dislikes
  *RATING*       : the rating of the video from 0 to 5
  *COMMENTS*     : the number of comments
  *DURATION*     : the duration of the video in seconds
  *PUBLISHED*    : the publication date as "DD MMM YYYY"
  *AGE*          : the age of a video (N days, N months, N years)
  *AGE_SHORT*    : the abbreviated age of a video (Nd, Nm, Ny)
  *DIMENSION*    : the dimension of the video (2D or 3D)
  *DEFINITION*   : the definition of the video (HD or SD)
  *TIME*         : the duration of the video as "HH::MM::SS"
  *TITLE*        : the title of the video
  *FTITLE*       : the title of the video (filename safe)
  *DESCRIPTION*  : the description of the video

  *URL*      : the YouTube URL of the video
  *ITAG*     : the itag value of the video
  *FORMAT*   : the extension of the video (without the dot)

  *CAPTION*  : true if the video has captions
  *SUB*      : the local subtitle file (if any)
  *AUDIO*    : the audio URL of the video (only in DASH mode)
  *VIDEO*    : the video URL of the video (it might not contain audio)
  *AOV*      : audio URL (if any) or video URL (in this order)

-> Special escapes:
    \\t                  tab
    \\n                  newline
    \\r                  return
    \\f                  form feed
    \\b                  backspace
    \\a                  alarm (bell)
    \\e                  escape

-> Extracting information from videos:
 > Extracting information can be achieved by using the "--extract" command-line
   option which takes a given format as its argument, which is defined by using
   special tokens, special escapes or literals.

   Example:
     $execname --no-interactive --extract '*TITLE* (*ID*)' [URL]

-> Configuration file: $config_file

-> Donations gladly accepted:
    https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=75FUVBE6Q73T8

TRICKS
    main_quit(0);
}

sub examples {
    print <<"EXAMPLES";
==== COMMAND LINE EXAMPLES ====

Command: $execname -A -n russian music -category=music
Results: play all the video results (-A)
         only audio, no video (-n)
         search for "russian music"
         in the Music category.
Note:    -A will include the videos from the next pages as well.

Command: $execname --comments 'https://www.youtube.com/watch?v=U6_8oIPFREY'
Results: show video comments for a specific video URL or videoID.

Command: $execname --results=5 -up=khanacademy
Results: the most recent 5 playlists by a specific author (-up).

Command: $execname --author=MIT atom
Results: search only in videos by a specific author.

Command: $execname --author=MIT atom --within=2y
Results: search only in videos by a specific author, published in the last 2 years.

Command: $execname --popular=MIT --within=6m
Results: show the most popular videos by a specific user, published in the last 6 months.

Command: $execname -S=vsauce
Results: get the subscriptions for a username.

Command: $execname --page=2 -u=Google
Results: show the latest videos uploaded by Google, starting with the page number 2.

Command: $execname cats --order=viewCount --duration=short
Results: search for 'cats' videos, ordered by ViewCount and short duration.

Command: $execname -sc math lessons
Results: search for YouTube channels.

Command: $execname -uf=Google
Results: show the latest favorite videos by a user.


==== USER INPUT EXAMPLES ====

A STDIN option can begin with ':', ';' or '='.

Command: <ENTER>, :n, :next
Results: get the next page of results.

Command: :b, :back (:r, :return)
Results: get the previous page of results.

Command: :i4..6, :i7-9, :i20-4, :i2, :i=4, :info=4
Results: show extra information for the selected videos.

Command: :d5,2, :d=3, :download=8
Results: download the selected videos.

Command: :c2, :comments=4
Results: show comments for a selected video.

Command: :r4, :related=6
Results: show related videos for a selected video.

Command: :a14, :author=12
Results: show videos uploaded by the author who uploaded the selected video.

Command: :p9, :playlists=14
Results: show playlists created by the author who uploaded the selected video.

Command: :subscribe=7
Results: subscribe to the author's channel who uploaded the selected video.

Command: :like=2, :dislike=4,5
Results: like or dislike the selected videos.

Command: :fav=4, :favorite=3..5
Results: favorite the selected videos.

Command: 3, 5..7, 12-1, 9..4, 2 3 9
Results: play the selected videos.

Command: :q3,5, :q=4, :queue=3-9
Results: enqueue the selected videos to play them later.

Command: :pq, :play-queue
Results: play the videos enqueued by the :queue option.

Command: :re='^Linux'
Results: play videos matched by a regex.
Example: matches title: "Linux video"

Command: :regex='linux.*part \\d+/\\d+'
Example: matches title: "Introduction to Linux (part 1/4)"

Command: :anp 1 2 3
Results: play the first three videos from every page.

Command: :r, :return
Results: return to the previous section.
EXAMPLES
    main_quit(0);
}

sub stdin_help {
    print $complete_help;
    main_quit(0);
}

# Print version
sub version {
    print "$appname $version\n";
    main_quit(0);
}

sub apply_configuration {
    my ($opt, $keywords) = @_;

    if ($yv_obj->get_debug >= 2 or (defined($opt->{debug}) && $opt->{debug} >= 2)) {
        require Data::Dump;
        say "=>> Options with keywords: <@{$keywords}>";
        Data::Dump::pp($opt);
    }

    # ... BASIC OPTIONS ... #
    if (delete $opt->{quiet}) {
        close STDERR;
    }

    if (delete $opt->{really_quiet}) {
        close STDERR;
        close STDOUT;
    }

    # ... YOUTUBE OPTIONS ... #
    foreach my $option_name (
                             qw(
                             videoCaption maxResults order
                             videoDefinition videoCategoryId
                             videoDimension videoDuration
                             videoEmbeddable videoLicense
                             videoSyndicated channelId
                             publishedAfter publishedBefore
                             safeSearch regionCode debug hl
                             http_proxy page comments_order
                             subscriptions_order user_agent
                             cookie_file timeout ytdl ytdl_cmd
                             prefer_mp4 prefer_av1 force_fallback
                             bypass_age_gate_native bypass_age_gate_with_proxy
                             )
      ) {

        if (defined $opt->{$option_name}) {

            my $code      = \&{"WWW::YoutubeViewer::set_$option_name"};
            my $value     = $opt->{$option_name};                         # don't delete this value!
            my $set_value = $yv_obj->$code($value);

            if (not defined($set_value) or $set_value ne $value) {
                warn "\n[!] Invalid value <$value> for option <$option_name>\n";
            }
        }
    }

    if (defined $opt->{category_id}) {

        my $str      = delete $opt->{category_id};
        my $category = extract_category($str);

        if (ref($category) eq 'HASH') {
            say ":: Category selected: $category->{snippet}{title}" if $yv_obj->get_debug;
            $yv_obj->set_videoCategoryId($category->{id});
        }
        else {
            warn_invalid('category', $str);
        }
    }

    if (defined $opt->{hd}) {
        $yv_obj->set_videoDefinition(delete($opt->{hd}) ? 'high' : 'any');
    }

    if (defined $opt->{author}) {
        my $name = delete $opt->{author};
        if (my $id = extract_channel_id($name)) {

            if (not $yv_utils->is_channelID($id)) {
                $id = $yv_obj->channel_id_from_username($id) // do {
                    warn_invalid("username or channel ID", $id);
                    undef;
                };
            }

            if ($id eq 'mine') {
                $id = $yv_obj->my_channel_id() // do {
                    warn_invalid("username or channel ID", $id);
                    undef;
                };
            }

            $yv_obj->set_channelId($id);
        }
        else {
            warn_invalid("username or channel ID", $name);
        }
    }

    if (defined $opt->{within}) {
        my $value = delete $opt->{within};

        if ($value =~ /^any/i) {
            $yv_obj->set_publishedAfter(undef);
            $yv_obj->set_publishedBefore(undef);
        }
        elsif ($value =~ /^\s*(\d+(?:\.\d+)?)([dwmy])/i) {
            my $date = $yv_utils->period_to_date($1, $2);
            $yv_obj->set_publishedAfter($date);
            $yv_obj->set_publishedBefore(undef);
        }
        else {
            warn "\n[!] Invalid value <$value> for option `--within`!\n";
        }
    }

    if (defined $opt->{before}) {
        my $value = delete $opt->{before};

        if ($value =~ /^any/i) {
            $yv_obj->set_publishedAfter(undef);
            $yv_obj->set_publishedBefore(undef);
        }
        elsif ($value =~ /^\s*(\d+(?:\.\d+)?)([dwmy])/i) {
            my $date = $yv_utils->period_to_date($1, $2);
            $yv_obj->set_publishedBefore($date);
            $yv_obj->set_publishedAfter(undef);
        }
        else {
            warn "\n[!] Invalid value <$value> for option `--before`!\n";
        }
    }

    if (defined $opt->{more_results}) {
        $yv_obj->set_maxResults(delete($opt->{more_results}) ? 50 : $CONFIG{maxResults});
    }

    if (delete $opt->{authenticate}) {
        authenticate();
    }

    if (delete $opt->{logout}) {
        logout();
    }

    # ... OTHER OPTIONS ... #
    if (defined $opt->{extract_info_file}) {
        open my $fh, '>:utf8', delete($opt->{extract_info_file});
        $opt{extract_info_fh} = $fh;
    }

    if (defined $opt->{colors}) {
        $opt{_colors} = $opt->{colors};
        if (delete $opt->{colors}) {
            require Term::ANSIColor;
            no warnings 'redefine';
            *colored    = \&Term::ANSIColor::colored;
            *colorstrip = \&Term::ANSIColor::colorstrip;
        }
        else {
            no warnings 'redefine';
            *colored    = sub { $_[0] };
            *colorstrip = sub { $_[0] };
        }
    }

    # ... SUBROUTINE CALLS ... #
    if (defined $opt->{subscribe}) {
        subscribe(split(/[,\s]+/, delete $opt->{subscribe}));
    }

    if (defined $opt->{unsubscribe}) {
        unsubscribe(split(/[,\s]+/, delete $opt->{unsubscribe}));
    }

    if (defined $opt->{favorite_video}) {
        favorite_videos(split(/[,\s]+/, delete $opt->{favorite_video}));
    }

    if (defined $opt->{playlist_save}) {
        my @ids = split(/[,\s]+/, delete $opt->{playlist_save});
        if (defined $opt->{playlist_id}) {
            save_to_playlist(get_valid_playlist_id(delete $opt->{playlist_id}) // (return), @ids);
        }
        else {
            select_and_save_to_playlist(@ids);
        }
    }

    if (defined $opt->{like_video}) {
        rate_videos('like', split(/[,\s]+/, delete $opt->{like_video}));
    }

    if (defined $opt->{dislike_video}) {
        rate_videos('dislike', split(/[,\s]+/, delete $opt->{dislike_video}));
    }

    if (defined $opt->{play_video_ids}) {
        get_and_play_video_ids(split(/[,\s]+/, delete $opt->{play_video_ids}));
    }

    if (defined $opt->{play_playlists}) {
        get_and_play_playlists(split(/[,\s]+/, delete $opt->{play_playlists}));
    }

    if (defined $opt->{local_channels}) {
        print_local_channels(delete $opt->{local_channels});
    }

    if (defined $opt->{local_playlist}) {
        print_local_playlist(delete $opt->{local_playlist});
    }

    if (defined $opt->{save_video}) {
        my $videoID = get_valid_video_id(delete($opt->{save_video})) // return;
        save_video_to_file($videoID);
    }

    if (defined $opt->{save_playlist}) {
        my $playlistID = get_valid_playlist_id(delete($opt->{save_playlist})) // return;
        save_playlist_to_file($playlistID);
    }

    if (defined $opt->{save_channel}) {
        my $channelID = delete($opt->{save_channel});
        save_channel_to_file($channelID);
    }

    if (defined $opt->{playlist_id}) {
        my $playlistID = get_valid_playlist_id(delete($opt->{playlist_id})) // return;
        get_and_print_videos_from_playlist($playlistID);
    }

    if (delete $opt->{search_videos}) {
        if (not @{$keywords}) {
            print_saved_videos();
        }
        else {
            print_videos($yv_obj->search_videos([@{$keywords}]));
        }
    }

    if (delete $opt->{search_channels}) {
        print_channels($yv_obj->search_channels([@{$keywords}]));
    }

    if (delete $opt->{search_playlists}) {
        print_playlists($yv_obj->search_playlists([@{$keywords}]));
    }

    if (delete $opt->{categories}) {
        print_categories($yv_obj->video_categories);
    }

    if (delete $opt->{watched_videos}) {
        print_watched_videos();
    }

    if (delete $opt->{saved_videos}) {
        print_saved_videos();
    }

    if (delete $opt->{local_subscriptions}) {
        print_local_subscription_videos();
    }

    if (defined $opt->{uploads}) {
        my $str = delete $opt->{uploads};

        if ($str) {
            if (my $id = extract_channel_id($str)) {
                $yv_utils->is_channelID($id)
                  ? print_videos($yv_obj->uploads($id))
                  : print_videos($yv_obj->uploads_from_username($id));
            }
            else {
                warn_invalid("username or channel ID", $str);
            }
        }
        else {
            print_videos($yv_obj->uploads);
        }
    }

    if (defined $opt->{popular_videos}) {
        my $str = delete $opt->{popular_videos};

        if (!defined($str) or $str eq '') {
            print_videos($yv_obj->popular_videos);
        }
        elsif (my $id = extract_channel_id($str)) {

            if (not $yv_utils->is_channelID($id)) {
                $id = $yv_obj->channel_id_from_username($id) // do {
                    warn_invalid("username or channel ID", $id);
                    undef;
                };
            }

            if (defined($id) and $id eq 'mine') {
                $id = $yv_obj->my_channel_id() // do {
                    warn_invalid("username or channel ID", $id);
                    undef;
                };
            }

            print_videos($yv_obj->popular_videos($id));
        }
        else {
            warn_invalid("username or channel ID", $str);
        }
    }

    if (defined $opt->{trending}) {

        my $str      = delete $opt->{trending};
        my $category = extract_category($str);
        my $cat_id   = undef;

        if (ref($category) eq 'HASH') {
            say ":: Category selected: $category->{snippet}{title}" if $yv_obj->get_debug;
            $cat_id = $category->{id};
        }
        elsif ($str) {
            warn_invalid('category', $str);
        }

        print_videos($yv_obj->videos_from_category($cat_id));
    }

    if (defined $opt->{subscriptions}) {
        my $str = delete $opt->{subscriptions};

        if ($str) {
            if (my $id = extract_channel_id($str)) {
                $yv_utils->is_channelID($id)
                  ? print_channels($yv_obj->subscriptions($id))
                  : print_channels($yv_obj->subscriptions_from_username($id));
            }
            else {
                warn_invalid("username or channel ID", $str);
            }
        }
        else {
            print_channels($yv_obj->subscriptions);
        }
    }

    if (defined $opt->{subscription_videos}) {
        my $str = delete $opt->{subscription_videos};

        if ($str) {
            if (my $id = extract_channel_id($str)) {
                $yv_utils->is_channelID($id)
                  ? print_videos($yv_obj->subscription_videos($id))
                  : print_videos($yv_obj->subscription_videos_from_username($id));
            }
            else {
                warn_invalid("username or channel ID", $str);
            }
        }
        else {
            print_videos($yv_obj->subscription_videos);
        }
    }

    if (defined $opt->{related_videos}) {
        get_and_print_related_videos(split(/[,\s]+/, delete($opt->{related_videos})));
    }

    if (defined $opt->{playlists}) {
        my $str = delete($opt->{playlists});

        if ($str) {
            if (my $id = extract_channel_id($str)) {
                $yv_utils->is_channelID($id)
                  ? print_playlists($yv_obj->playlists($id))
                  : print_playlists($yv_obj->playlists_from_username($id));
            }
            else {
                warn_invalid("username or channel ID", $str);
                warn colored("[+] To search for playlists, try: $0 -sp $str", 'bold yellow') . "\n";
            }
        }
        else {
            print_playlists($yv_obj->my_playlists);
        }
    }

    if (defined $opt->{favorites}) {
        my $str = delete($opt->{favorites});

        if ($str) {
            if (my $id = extract_channel_id($str)) {
                $yv_utils->is_channelID($id)
                  ? print_videos($yv_obj->favorites($id))
                  : print_videos($yv_obj->favorites_from_username($id));
            }
            else {
                warn_invalid("username or channel ID", $str);
            }
        }
        else {
            print_videos($yv_obj->favorites);
        }
    }

    if (defined $opt->{likes}) {
        my $str = delete($opt->{likes});

        if ($str) {
            if (my $id = extract_channel_id($str)) {
                $yv_utils->is_channelID($id)
                  ? print_videos($yv_obj->likes($id))
                  : print_videos($yv_obj->likes_from_username($id));
            }
            else {
                warn_invalid("username or channel ID", $str);
            }
        }
        else {
            print_videos($yv_obj->my_likes);
        }
    }

    if (defined $opt->{dislikes}) {
        delete $opt->{dislikes};
        print_videos($yv_obj->my_dislikes);
    }

    if (defined $opt->{activities}) {
        my $str = delete $opt->{activities};

        if ($str) {
            if (my $id = extract_channel_id($str)) {
                $yv_utils->is_channelID($id)
                  ? print_videos($yv_obj->activities($id))
                  : print_videos($yv_obj->activities_from_username($id));
            }
            else {
                warn_invalid("username or channel ID", $str);
            }
        }
        else {
            print_videos($yv_obj->my_activities);
        }
    }

    if (defined $opt->{get_comments}) {
        get_and_print_comments(split(/[,\s]+/, delete($opt->{get_comments})));
    }

    if (defined $opt->{print_video_info}) {
        get_and_print_video_info(split(/[,\s]+/, delete $opt->{print_video_info}));
    }
}

sub parse_arguments {
    my ($keywords) = @_;

    state $x = do {
        require Getopt::Long;
        Getopt::Long::Configure('no_ignore_case');
    };

    my %orig_opt         = %opt;
    my $orig_config_file = "$config_file";

    Getopt::Long::GetOptions(

        # Main options
        'help|usage|h|?'        => \&help,
        'examples|E'            => \&examples,
        'stdin-help|shelp|sh|H' => \&stdin_help,
        'tricks|tips|T'         => \&tricks,
        'version|v'             => \&version,

        'config=s'       => \$config_file,
        'update-config!' => sub { dump_configuration($config_file) },

        # Resolutions
        'audio|a' => sub { $opt{resolution} = 'audio' },
        '144p'    => sub { $opt{resolution} = 144 },
        '240p|2'  => sub { $opt{resolution} = 240 },
        '360p|3'  => sub { $opt{resolution} = 360 },
        '480p|4'  => sub { $opt{resolution} = 480 },
        '720p|7'  => sub { $opt{resolution} = 720 },
        '1080p|1' => sub { $opt{resolution} = 1080 },
        '1440p'   => sub { $opt{resolution} = 1440 },
        '2160p'   => sub { $opt{resolution} = 2160 },
        'best'    => sub { $opt{resolution} = 'best' },

        'hfr!'             => \$opt{hfr},
        'res|resolution=s' => \$opt{resolution},

        'comments=s'       => \$opt{get_comments},
        'comments-order=s' => \$opt{comments_order},

        'c|categories'                => \$opt{categories},
        'video-ids|videoids|id|ids=s' => \$opt{play_video_ids},

        'lc|fc|local-channels:s'       => \$opt{local_channels},
        'lp|local-playlists:s'         => \$opt{local_playlist},
        'wv|watched-videos'            => \$opt{watched_videos},
        'lv|local-videos|saved-videos' => \$opt{saved_videos},
        'ls|local-subs'                => \$opt{local_subscriptions},

        'save-video|save=s' => \$opt{save_video},
        'save-channel=s'    => \$opt{save_channel},
        'save-playlist=s'   => \$opt{save_playlist},

        'search-videos|search|sv!'     => \$opt{search_videos},
        'search-channels|channels|sc!' => \$opt{search_channels},
        'search-playlists|sp|p!'       => \$opt{search_playlists},

        'subscriptions|S:s'                 => \$opt{subscriptions},
        'subs-videos|SV:s'                  => \$opt{subscription_videos},
        'subs-order=s'                      => \$opt{subscriptions_order},
        'uploads|U|user|user-videos|uv|u:s' => \$opt{uploads},
        'favorites|F|user-favorites|uf:s'   => \$opt{favorites},
        'playlists|P|user-playlists|up:s'   => \$opt{playlists},
        'activities|activity|ua:s'          => \$opt{activities},
        'likes|L|user-likes|ul:s'           => \$opt{likes},
        'dislikes'                          => \$opt{dislikes},
        'subscribe=s'                       => \$opt{subscribe},
        'unsubscribe=s'                     => \$opt{unsubscribe},

        'trending|trends:s' => \$opt{trending},
        'playlist-id|pid=s' => \$opt{playlist_id},

        # English-UK friendly
        'favorite|favourite|favorite-video|favourite-video|fav=s' => \$opt{favorite_video},

        'login|authenticate' => \$opt{authenticate},
        'logout'             => \$opt{logout},

        'related-videos|rv=s'         => \$opt{related_videos},
        'popular-videos|popular|pv:s' => \$opt{popular_videos},

        'cookie-file|cookies=s'          => \$opt{cookie_file},
        'user-agent|agent=s'             => \$opt{user_agent},
        'http-proxy|https-proxy|proxy=s' => \$opt{http_proxy},

        'catlang|cl|hl=s'        => \$opt{hl},
        'category|cat-id|cat=s'  => \$opt{category_id},
        'r|region|region-code=s' => \$opt{regionCode},

        'orderby|order|order-by=s' => \$opt{order},
        'duration=s'               => \$opt{videoDuration},
        'within|since=s'           => \$opt{within},
        'before=s'                 => \$opt{before},

        'max-seconds|max_seconds=i' => \$opt{max_seconds},
        'min-seconds|min_seconds=i' => \$opt{min_seconds},

        'like=s'                     => \$opt{like_video},
        'dislike=s'                  => \$opt{dislike_video},
        'author=s'                   => \$opt{author},
        'all|A|play-all!'            => \$opt{play_all},
        'backwards|B!'               => \$opt{play_backwards},
        'input|std-input=s'          => \$opt{std_input},
        'use-colors|colors|colored!' => \$opt{colors},

        'autoplay!' => \$opt{autoplay_mode},

        'play-playlists|pp=s'      => \$opt{play_playlists},
        'debug:1'                  => \$opt{debug},
        'download|dl|d!'           => \$opt{download_video},
        'safe-search|safeSearch=s' => \$opt{safeSearch},
        'vd|video-definition=s'    => \$opt{videoDefinition},
        'hd|high-definition!'      => \$opt{hd},
        'license=s'                => \$opt{videoLicense},
        'dimension=s'              => \$opt{videoDimension},
        'I|interactive!'           => \$opt{interactive},
        'convert-to|convert_to=s'  => \$opt{convert_to},
        'keep-original-video!'     => \$opt{keep_original_video},
        'e|extract|extract-info=s' => \$opt{extract_info},
        'extract-file=s'           => \$opt{extract_info_file},
        'escape-info!'             => \$opt{escape_info},

        'dump=s' => sub {
            my (undef, $format) = @_;
            $opt{dump} = (
                ($format =~ /json/i) ? 'json' : ($format =~ /perl/i) ? 'perl' : do {
                    warn "[!] Invalid format <<$format>> for option --dump\n";
                    undef;
                }
            );
        },

        # Set a video player
        'player|vplayer|video-player|video_player=s' => sub {

            if (not exists $opt{video_players}{$_[1]}) {
                die "[!] Unknown video player selected: <<$_[1]>>\n";
            }

            $opt{video_player_selected} = $_[1];
        },

        'append-arg|append-args=s' => \$PLAYER_ARGS{user_defined_arguments},

        # Others
        'caption=s'        => \$opt{videoCaption},
        'fullscreen|fs|f!' => \$opt{fullscreen},
        'split-videos!'    => \$opt{split_videos},
        'confirm!'         => \$opt{confirm},

        'prefer-mp4!'     => \$opt{prefer_mp4},
        'prefer-m4a!'     => \$opt{prefer_m4a},
        'prefer-av1!'     => \$opt{prefer_av1},
        'ignore-av1!'     => \$opt{ignore_av1},
        'audio-quality=s' => \$opt{audio_quality},

        'fallback|force-fallback!' => \$opt{force_fallback},

        'custom-layout-format=s'          => \$opt{custom_layout_format},
        'custom-channel-layout-format=s'  => \$opt{custom_channel_layout_format},
        'custom-playlist-layout-format=s' => \$opt{custom_playlist_layout_format},

        'merge-into-mkv|mkv-merge!'           => \$opt{merge_into_mkv},
        'merge-with-captions|merge-captions!' => \$opt{merge_with_captions},

        'convert-command|convert-cmd=s'     => \$opt{convert_cmd},
        'dash-segmented!'                   => \$opt{dash_segmented},
        'wget-dl|wget-download!'            => \$opt{download_with_wget},
        'filename|filename-format=s'        => \$opt{video_filename_format},
        'rp|rem-played|remove-played-file!' => \$opt{remove_played_file},
        'info|i=s'                          => \$opt{print_video_info},
        'get-term-width!'                   => \$opt{get_term_width},
        'page=i'                            => \$opt{page},
        'novideo|no-video|n!'               => \$opt{novideo},
        'highlight!'                        => \$opt{highlight_watched},
        'autolike!'                         => \$opt{autolike_watched},
        'skip-watched!'                     => \$opt{skip_watched},
        'results=i'                         => \$opt{maxResults},
        'shuffle|s!'                        => \$opt{shuffle},
        'more|m!'                           => \$opt{more_results},
        'pos|position=i'                    => \$opt{position},
        'ps|playlist-save=s'                => \$opt{playlist_save},

        'ytdl!'      => \$opt{ytdl},
        'ytdl-cmd=s' => \$opt{ytdl_cmd},

        'quiet|q!'      => \$opt{quiet},
        'really-quiet!' => \$opt{really_quiet},
        'video-info!'   => \$opt{show_video_info},

        'dp|downl-play|download-and-play|dl-play!' => \$opt{download_and_play},

        'thousand-separator=s'           => \$opt{thousand_separator},
        'get-captions|get_captions!'     => \$opt{get_captions},
        'auto-captions|auto_captions!'   => \$opt{auto_captions},
        'srt-languages=s'                => \$opt{srt_languages},
        'copy-caption|copy_caption!'     => \$opt{copy_caption},
        'skip-if-exists|skip_if_exists!' => \$opt{skip_if_exists},
        'downloads-dir|download-dir=s'   => \$opt{downloads_dir},
        'fat32safe!'                     => \$opt{fat32safe},
      )
      or warn "[!] Error in command-line arguments!\n";

    if ($config_file ne $orig_config_file) {    # load the config file specified with `--config=s`
        ##say ":: Loading config: $config_file";
        $config_file = rel2abs($config_file);

        my %new_opt = %opt;
        load_config($config_file);

        foreach my $key (keys %new_opt) {
            if (    defined($new_opt{$key})
                and defined($orig_opt{$key})
                and $new_opt{$key} ne $orig_opt{$key}) {
                $opt{$key} = $new_opt{$key};
            }
        }
    }

    apply_configuration(\%opt, $keywords);
}

# Parse the arguments
if (@ARGV) {
    require Encode;
    @ARGV = map { Encode::decode_utf8($_) } @ARGV;
    parse_arguments(\@ARGV);
}

for (my $i = 0 ; $i <= $#ARGV ; $i++) {
    my $arg = $ARGV[$i];

    next if (substr($arg, 0, 1) eq q{-});

    if (youtube_urls($arg)) {
        splice(@ARGV, $i--, 1);
    }
}

if (my @keywords = grep { substr($_, 0, 1) ne q{-} } @ARGV) {
    print_videos($yv_obj->search_videos(\@keywords));
}
elsif ($opt{interactive} and -t) {
    first_user_input();
}
elsif ($opt{interactive} and -t STDOUT and not -t) {
    print_videos($yv_obj->search_videos(scalar <STDIN>));
}
else {
    main_quit($opt{_error} || 0);
}

sub get_valid_video_id {
    my ($value) = @_;

    my $id =
        $value =~ /$get_video_id_re/   ? $+{video_id}
      : $value =~ /$valid_video_id_re/ ? $value
      :                                  undef;

    if (not defined $id) {
        warn_invalid('videoID', $value);
        return;
    }

    return $id;
}

sub get_valid_playlist_id {
    my ($value) = @_;

    my $id =
        $value =~ /$get_playlist_id_re/   ? $+{playlist_id}
      : $value =~ /$valid_playlist_id_re/ ? $value
      :                                     undef;

    if (not defined $id) {
        warn_invalid('playlistID', $value);
        return;
    }

    return $id;
}

sub extract_category {
    my ($str) = @_;

    $str || return;

    state $results = $yv_obj->video_categories;
    return if ref($results) ne 'HASH';

    my $categories = $results->{items};
    return if ref($categories) ne 'ARRAY';

    foreach my $category (@$categories) {
        if ($category->{id} eq $str) {
            return $category;
        }
    }

    my $str_re = qr/\Q$str\E/i;

    foreach my $category (@$categories) {
        if ($yv_utils->get_title($category) =~ /$str_re/) {
            return $category;
        }
    }

    return;
}

sub extract_channel_id {
    my ($str) = @_;

    if ($str =~ /$get_channel_videos_id_re/) {
        return $+{channel_id};
    }

    if ($str =~ /$get_username_videos_re/) {
        return $+{username};
    }

    if ($str =~ /$valid_channel_id_re/) {
        return $+{channel_id};
    }

    if ($str =~ /^[-a-zA-Z0-9_]+\z/) {
        return $str;
    }

    return undef;
}

sub apply_input_arguments {
    my ($args, $keywords) = @_;

    if (@{$args}) {
        local @ARGV = @{$args};
        parse_arguments($keywords);
    }

    return 1;
}

# Get term width
sub get_term_width {
    return $term_width if $constant{win32};
    $term_width = (-t STDOUT) ? ((split(q{ }, `stty size`))[1] || $term_width) : $term_width;
}

sub first_user_input {
    my @keys = get_input_for_first_time();

    state $first_input_help = <<"HELP";

$base_options
$action_options
$other_options
$notes_options
** Example:
    To search for playlists, insert: -p keywords
HELP

    if (scalar(@keys)) {
        my @for_search;
        foreach my $key (@keys) {
            if ($key =~ /$valid_opt_re/) {

                my $opt = $1;

                if (general_options(opt => $opt)) {
                    ## ok
                }
                elsif ($opt =~ /^(?:h|help)\z/) {
                    print $first_input_help;
                    press_enter_to_continue();
                }
                elsif ($opt =~ /^(?:r|return)\z/) {
                    return;
                }
                else {
                    warn_invalid('option', $opt);
                    print "\n";
                    exit 1;
                }
            }
            elsif (youtube_urls($key)) {
                ## ok
            }
            else {
                push @for_search, $key;
            }
        }

        if (scalar(@for_search) > 0) {
            print_videos($yv_obj->search_videos(\@for_search));
        }
        else {
            __SUB__->();
        }
    }
    else {
        __SUB__->();
    }
}

sub get_quotewords {
    require Text::ParseWords;
    Text::ParseWords::quotewords(@_);
}

sub clear_title {
    my ($title) = @_;

    $title //= "";
    $title =~ s/[^\w\s[:punct:]]//g;
    $title = join(' ', split(' ', $title));

    return $title;
}

# Straight copy of parse_options() from Term::UI
sub _parse_options {
    my ($input) = @_;

    my $return = {};
    while (   $input =~ s/(?:^|\s+)--?([-\w]+=(["']).+?\2)(?=\Z|\s+)//
           or $input =~ s/(?:^|\s+)--?([-\w]+=\S+)(?=\Z|\s+)//
           or $input =~ s/(?:^|\s+)--?([-\w]+)(?=\Z|\s+)//) {
        my $match = $1;

        if ($match =~ /^([-\w]+)=(["'])(.+?)\2$/) {
            $return->{$1} = $3;

        }
        elsif ($match =~ /^([-\w]+)=(\S+)$/) {
            $return->{$1} = $2;

        }
        elsif ($match =~ /^no-?([-\w]+)$/i) {
            $return->{$1} = 0;

        }
        elsif ($match =~ /^([-\w]+)$/) {
            $return->{$1} = 1;
        }
    }

    return wantarray ? ($return, $input) : $return;
}

sub parse_options2 {
    my ($input) = @_;

    warn(colored("\n[!] Input with an odd number of quotes: <$input>", 'bold red') . "\n\n")
      if $yv_obj->get_debug;

    my ($args, $keywords) = _parse_options($input);

    my @args =
      map { $args->{$_} eq '0' ? "--no-$_" : $args->{$_} eq '1' ? "--$_" : "--$_=$args->{$_}" } keys %{$args};

    return wantarray ? (\@args, [split q{ }, $keywords]) : \@args;
}

sub parse_options {
    my ($input) = @_;
    my (@args, @keywords);

    if (not defined($input) or $input eq q{}) {
        return \@args, \@keywords;
    }

    foreach my $word (get_quotewords(qr/\s+/, 0, $input)) {
        if (substr($word, 0, 1) eq q{-}) {
            push @args, $word;
        }
        else {
            push @keywords, $word;
        }
    }

    if (not @args and not @keywords) {
        return parse_options2($input);
    }

    return wantarray ? (\@args, \@keywords) : \@args;
}

sub get_user_input {
    my ($text) = @_;

    if (not $opt{interactive}) {
        if (not defined $opt{std_input}) {
            return ':return';
        }
    }

    my $input = unpack(
        'A*',
        defined($opt{std_input})
        ? delete($opt{std_input})
        : (
           do {
               my @lines = split(/\R/, $text);
               say for @lines[0 .. $#lines - 1];
               $term->readline($lines[-1]);
             }
             // return ':return'
          )
    ) =~ s/^\s+//r;

    return q{:next} if $input eq q{};    # <ENTER> for the next page

    require Encode;
    $input = Encode::decode_utf8($input);

    my ($args, $keywords) = parse_options($input);

    if ($opt{history}) {
        my $str = join(' ', grep { /\w/ } @{$args}, @{$keywords});
        if ($str ne '' and $str !~ /^[0-9]{1,2}\z/) {
            eval { $term->append_history(1, $opt{history_file}) };
        }
    }

    apply_input_arguments($args, $keywords);
    return @{$keywords};
}

sub logout {

    unlink $authentication_file
      or warn "[!] Can't unlink: `$authentication_file' -> $!";

    $yv_obj->set_access_token();
    $yv_obj->set_refresh_token();

    return 1;
}

sub authenticate {

    say "\n:: OAuth 2.0 for TV and Limited-Input Device Applications.";
    say ":: Using the following scope: https://www.googleapis.com/auth/youtube";
    say "\n:: Press <ENTER> to begin the authentication process!";

    <STDIN>;    # wait for user input

    my $code_info = $yv_obj->get_user_auth_code() // return;

    if ($code_info->{error}) {
        warn "Couldn't get the user code: $code_info->{error}\n";
        return;
    }

    my $device_code      = $code_info->{device_code}      // return;
    my $user_code        = $code_info->{user_code}        // return;
    my $verification_url = $code_info->{verification_url} // return;

    say ":: Open the following link:";
    say "\n\t$verification_url";
    say "\nand insert the following user code: $user_code";
    say "\n:: After granting access, press <ENTER>.";

    <STDIN>;    # wait for user input

    sleep 2;    # just to be sure

    my $info = $yv_obj->oauth_login_tv($code_info) // do {
        warn "[WARNING] Can't log in... That's all I know...\n";
        return;
    };

    if (defined $info->{access_token}) {

        $yv_obj->set_access_token($info->{access_token})   // return;
        $yv_obj->set_refresh_token($info->{refresh_token}) // return;

        my $remember_me = ask_yn(prompt  => colored("\nRemember me", 'bold'),
                                 default => 'y');

        if ($remember_me) {
            $yv_obj->set_authentication_file($authentication_file);
            $yv_obj->save_authentication_tokens()
              or warn "[!] Can't store the authentication tokens: $!";
        }
        else {
            $yv_obj->set_authentication_file();
        }

        return 1;
    }

    warn "[WARNING] There was a problem with the authentication...\n";
    return;
}

sub authenticated {
    if (not defined $yv_obj->get_access_token) {
        warn_needs_auth();
        return;
    }
    return 1;
}

sub favorite_videos {
    my (@videoIDs) = @_;
    return if not authenticated();

    foreach my $id (@videoIDs) {
        my $videoID = get_valid_video_id($id) // next;

        if ($yv_obj->favorite_video($videoID)) {
            printf("\n:: Video %s has been successfully favorited.\n", sprintf($CONFIG{youtube_video_url}, $videoID));
        }
        else {
            warn_cant_do('favorite', $videoID);
        }
    }
    return 1;
}

sub select_and_save_to_playlist {
    return if not authenticated();

    my $request    = $yv_obj->my_playlists() // return;
    my $playlistID = print_playlists($request, return_playlist_id => 1);

    if (defined($playlistID)) {
        return save_to_playlist($playlistID, @_);
    }

    warn_no_thing_selected('playlist');
    return;

}

sub save_to_playlist {
    my ($playlistID, @videoIDs) = @_;

    return if not authenticated();

    foreach my $id (@videoIDs) {
        my $videoID = get_valid_video_id($id) // next;
        my $pos     = $opt{position};                    # position in the playlist

        if (!defined($pos) or $pos < 0) {
            local $yv_obj->{maxResults} = 1;

            my $info          = $yv_obj->videos_from_playlist_id($playlistID);
            my $total_results = $info->{results}{pageInfo}{totalResults};

            say "\n:: Total number of videos in the playlist: $total_results";
            $pos //= 0;
            $pos += $total_results || 0;
            say ":: Saving video at position: $pos";
        }

        if ($yv_obj->add_video_to_playlist($playlistID, $videoID, $pos)) {
            printf(":: Video %s has been successfully added to playlistID: %s\n", sprintf($CONFIG{youtube_video_url}, $videoID), $playlistID);
        }
        else {
            warn_cant_do("add to playlist", $videoID);
        }
    }
    return 1;
}

sub rate_videos {
    my $rating = shift;
    return if not authenticated();

    foreach my $id (@_) {
        my $videoID = get_valid_video_id($id) // next;
        if ($yv_obj->send_rating_to_video($videoID, $rating)) {
            printf("\n:: Video %s has been successfully %sd.\n", sprintf($CONFIG{youtube_video_url}, $videoID), $rating);
        }
        else {
            warn_cant_do($rating, $videoID);
        }
    }

    return 1;
}

sub get_and_play_video_ids {
    (my @ids = grep { defined($_) } map { get_valid_video_id($_) } @_) || return;

    while (@ids) {
        my @video_ids = splice(@ids, 0, 50);
        my $info      = $yv_obj->video_details(join(',', @video_ids), VIDEO_PART);

        if ($yv_utils->has_entries($info)) {
            play_videos($info->{results}{items}) || return;
        }
        else {
            warn_cant_do('get info for', @video_ids);
        }
    }

    return 1;
}

sub get_and_play_playlists {
    foreach my $id (@_) {
        my $videos = $yv_obj->videos_from_playlist_id(get_valid_playlist_id($id) // next);
        local $opt{play_all} = length($opt{std_input}) ? 0 : 1;
        print_videos($videos, auto => $opt{play_all});
    }
    return 1;
}

sub get_and_print_video_info {
    foreach my $id (@_) {

        my $videoID = get_valid_video_id($id) // next;
        my $info    = $yv_obj->video_details($videoID, VIDEO_PART);

        if ($yv_utils->has_entries($info)) {
            local $opt{show_video_info} = 1;
            print_video_info($info->{results}{items}[0]);
        }
        else {
            warn_cant_do('get info for', $videoID);
        }
    }
    return 1;
}

sub get_and_print_related_videos {
    foreach my $id (@_) {
        my $videoID = get_valid_video_id($id) // next;
        my $results = $yv_obj->related_to_videoID($videoID);
        print_videos($results);
    }
    return 1;
}

sub get_and_print_comments {
    foreach my $id (@_) {
        my $videoID  = get_valid_video_id($id) // next;
        my $comments = $yv_obj->comments_from_video_id($videoID);
        print_comments($comments, $videoID);
    }
    return 1;
}

sub get_and_print_videos_from_playlist {
    my ($playlistID) = @_;

    if ($playlistID =~ /$valid_playlist_id_re/) {
        my $info = $yv_obj->videos_from_playlist_id($playlistID);
        if ($yv_utils->has_entries($info)) {
            print_videos($info);
        }
        else {
            warn colored("\n[!] Inexistent playlist...", 'bold red') . "\n";
            return;
        }
    }
    else {
        warn_invalid('playlistID', $playlistID);
        return;
    }
    return 1;
}

sub subscribe {
    my (@ids) = @_;

    return if not authenticated();

    foreach my $channel (@ids) {

        my $id = extract_channel_id($channel) // do {
            warn_invalid("channel ID or username", $channel);
            next;
        };

        my $ok =
            $yv_utils->is_channelID($id)
          ? $yv_obj->subscribe_channel($id)
          : $yv_obj->subscribe_channel_from_username($id);

        if ($ok) {
            print ":: Successfully subscribed to channel: $id\n";
        }
        else {
            warn colored("\n[!] Unable to subscribe to channel: $id", 'bold red') . "\n";
        }
    }

    return 1;
}

sub unsubscribe {
    my (@ids) = @_;

    return if not authenticated();

    foreach my $channel (@ids) {

        my $id = extract_channel_id($channel) // do {
            warn_invalid("channel ID or username", $channel);
            next;
        };

        my $ok =
            $yv_utils->is_channelID($id)
          ? $yv_obj->unsubscribe_channel($id)
          : $yv_obj->unsubscribe_channel_from_username($id);

        if (defined($ok)) {
            print ":: Successfully unsubscribed from channel: $id\n";
        }
        else {
            warn colored("\n[!] Unable to unsubscribe from channel: $id", 'bold red') . "\n";
        }
    }

    return 1;
}

sub _bold_color {
    my ($text) = @_;
    return colored($text, 'bold');
}

sub youtube_urls {
    my ($arg) = @_;

    if ($arg ne 'mine' and $yv_utils->is_channelID($arg)) {
        print_videos($yv_obj->uploads($arg));
    }
    elsif ($yv_utils->is_playlistID($arg)) {
        get_and_print_videos_from_playlist($arg);
    }
    elsif ($arg =~ /$get_video_id_re/) {
        get_and_play_video_ids($+{video_id});
    }
    elsif ($arg =~ /$get_playlist_id_re/) {
        get_and_print_videos_from_playlist($+{playlist_id});
    }
    elsif ($arg =~ /$get_channel_playlists_id_re/) {
        print_playlists($yv_obj->playlists($+{channel_id}));
    }
    elsif ($arg =~ /$get_channel_videos_id_re/) {
        print_videos($yv_obj->uploads($+{channel_id}));
    }
    elsif ($arg =~ /$get_username_playlists_re/) {
        print_playlists($yv_obj->playlists_from_username($+{username}));
    }
    elsif ($arg =~ /$get_username_videos_re/) {
        print_videos($yv_obj->uploads_from_username($+{username}));
    }
    else {
        return;
    }

    return 1;
}

sub general_options {
    my %args = @_;

    my $url      = $args{url};
    my $option   = $args{opt};
    my $callback = $args{sub};
    my $results  = $args{res};
    my $info     = $args{info};

    if (not defined($option)) {
        return;
    }

    if ($option =~ /^(?:q|quit|exit)\z/) {
        main_quit(0);
    }
    elsif ($option =~ /^(page=(\S+)\z|(last|end|beg|first))/ and (defined($url) or ref($info->{fromPage}) eq 'CODE')) {

        my $page_number = parse_page_number($+, $info);
        say "\n:: Jumping to page $page_number" if ($page_number > 1);

        if (defined($info->{fromPage}) and ref($info->{fromPage}) eq 'CODE') {
            my $request = $info->{fromPage}->($page_number);
            $callback->($request);
        }
        else {
            my $page_token = $yv_obj->page_token($page_number);
            my $request    = $yv_obj->from_page_token($url, $page_token);
            $callback->($request);
        }
    }
    elsif ($option =~ /^(?:n|next)\z/ and (defined($url) or ref($info->{nextPageToken}) eq 'CODE')) {
        if (defined $info->{nextPageToken}) {
            my $request = $yv_obj->from_page_token($url, $info->{nextPageToken});
            $callback->($request);
        }
        else {
            warn_last_page();
        }
    }
    elsif ($option =~ /^(?:b|back|p|prev|previous)\z/ and (defined($url) or ref($info->{prevPageToken}) eq 'CODE')) {
        if (defined $info->{prevPageToken}) {
            my $request = $yv_obj->from_page_token($url, $info->{prevPageToken});
            $callback->($request);
        }
        else {
            warn_first_page();
        }
    }
    elsif ($option =~ /^(?:R|refresh)\z/ and defined $url) {
        @{$results} = @{$yv_obj->_get_results($url)->{results}{items}};
    }
    elsif ($option eq 'login') {
        authenticate();
    }
    elsif ($option eq 'logout') {
        logout();
    }
    elsif ($option =~ /^(?:reset|reload|restart)\z/) {
        @ARGV = ();
        do $0;
    }
    elsif ($option =~ /^dv${digit_or_equal_re}(.*)/ and ref($results) eq 'ARRAY') {
        if (my @nums = get_valid_numbers($#{$results}, $1)) {
            print "\n";
            foreach my $num (@nums) {
                require Data::Dump;
                say Data::Dump::pp($results->[$num]);
            }
            press_enter_to_continue();
        }
        else {
            warn_no_thing_selected('result');
        }
    }
    elsif ($option =~ /^v(?:ideoids?)?=(.*)/) {
        if (my @ids = split(/[,\s]+/, $1)) {
            get_and_play_video_ids(@ids);
        }
        else {
            warn colored("\n[!] No video ID specified!", 'bold red') . "\n";
        }
    }
    elsif ($option =~ /^playlist(?:ID)?=(.*)/) {
        get_and_print_videos_from_playlist($1);
    }
    else {
        return;
    }

    return 1;
}

sub warn_no_results {
    warn colored("\n[!] No $_[0] results!", 'bold red') . "\n";
}

sub warn_invalid {
    my ($name, $option) = @_;
    warn colored("\n[!] Invalid $name: <$option>", 'bold red') . "\n";
}

sub warn_cant_do {
    my ($action, @ids) = @_;

    foreach my $videoID (@ids) {
        warn colored("\n[!] Can't $action video: " . sprintf($CONFIG{youtube_video_url}, $videoID), 'bold red') . "\n";

        my %info = $yv_obj->_get_video_info($videoID);
        my $resp = $yv_obj->parse_json_string($info{player_response} // next);

        if (eval { exists($resp->{playabilityStatus}) and $resp->{playabilityStatus}{status} =~ /error/i }) {
            warn colored("[+] Reason: $resp->{playabilityStatus}{reason}.", 'bold yellow') . "\n";
        }
    }
}

sub warn_last_page {
    warn colored("\n[!] This is the last page!", "bold red") . "\n";
}

sub warn_first_page {
    warn colored("\n[!] This is the first page!", 'bold red') . "\n";
}

sub warn_no_thing_selected {
    warn colored("\n[!] No $_[0] selected!", 'bold red') . "\n";
}

sub warn_needs_auth {
    warn colored("\n[!] This functionality needs authentication!", 'bold red') . "\n";
}

# ... GET INPUT SUBS ... #
sub get_input_for_first_time {
    return get_user_input(_bold_color("\n=>> Search for YouTube videos (:h for help)") . "\n> ");
}

sub get_input_for_channels {
    return get_user_input(_bold_color("\n=>> Select a channel (:h for help)") . "\n> ");
}

sub get_input_for_search {
    return get_user_input(_bold_color("\n=>> Select one or more videos to play (:h for help)") . "\n> ");
}

sub get_input_for_playlists {
    return get_user_input(_bold_color("\n=>> Select a playlist (:h for help)") . "\n> ");
}

sub get_input_for_comments {
    return get_user_input(_bold_color("\n=>> Press <ENTER> for the next page of comments (:h for help)") . "\n> ");
}

sub get_input_for_categories {
    return get_user_input(_bold_color("\n=>> Select a category (:h for help)") . "\n> ");
}

sub ask_yn {
    my (%opt) = @_;
    my $c = join('/', map { $_ eq $opt{default} ? ucfirst($_) : $_ } qw(y n));

    my $answ;
    do {
        $answ = lc($term->readline($opt{prompt} . " [$c]: "));
        $answ = $opt{default} unless $answ =~ /\S/;
    } while ($answ !~ /^y(?:es)?$/ and $answ !~ /^no?$/);

    return chr(ord($answ)) eq 'y';
}

sub get_reply {
    my (%opt) = @_;

    my $default = 1;
    while (my ($i, $choice) = each @{$opt{choices}}) {
        print "\n" if $i == 0;
        printf("%3d> %s\n", $i + 1, $choice);
        if ($choice eq $opt{default}) {
            $default = $i + 1;
        }
    }
    print "\n";

    my $answ;
    do {
        $answ = $term->readline($opt{prompt} . " [$default]: ");
        $answ = $default unless $answ =~ /\S/;
    } while ($answ !~ /^[0-9]+\z/ or $answ < 1 or $answ > @{$opt{choices}});

    return $opt{choices}[$answ - 1];
}

sub valid_num {
    my ($num, $array_ref) = @_;
    return $num =~ /^[0-9]{1,2}\z/ && $num != 0 && $num <= @{$array_ref};
}

sub adjust_width {
    my ($str, $len, $prepend) = @_;

    if ($len <= 0) {
        return $str;
    }

    state $pkg = (
        eval {
            require Unicode::GCString;
            Unicode::GCString->new('test');
            'Unicode::GCString';
        } // eval {
            require Text::CharWidth;
            'Text::CharWidth';
        } // do {
            warn "[WARN] Please install Unicode::GCString or Text::CharWidth in order to use this functionality.\n";
            '';
        }
    );

    my $adjust_str = sub {

        # Unicode::GCString
        if ($pkg eq 'Unicode::GCString') {

            my $gcstr     = Unicode::GCString->new($str);
            my $str_width = $gcstr->columns;

            while ($str_width > $len) {
                $gcstr     = $gcstr->substr(0, -1);
                $str_width = $gcstr->columns;
            }

            $str = $gcstr->as_string;
            return ($str, $str_width);
        }

        # Text::CharWidth
        if ($pkg eq 'Text::CharWidth') {

            my $str_width = Text::CharWidth::mbswidth($str);

            while ($str_width > $len) {
                chop $str;
                $str_width = Text::CharWidth::mbswidth($str);
            }

            return ($str, $str_width);
        }

        # Fallback to counting graphemes
        my @graphemes = $str =~ /(\X)/g;

        while (scalar(@graphemes) > $len) {
            pop @graphemes;
        }

        $str = join('', @graphemes);
        return ($str, scalar(@graphemes));
    };

    my ($new_str, $str_width) = $adjust_str->();

    my $spaces = ' ' x ($len - $str_width);
    my $result = $prepend ? join('', $spaces, $new_str) : join('', $new_str, $spaces);

    return $result;
}

sub format_line_result {
    my ($i, $entry, $info, %args) = @_;

    if (ref($entry) eq '') {
        $entry =~ s/\*NO\*/sprintf('%2d', $i+1)/ge;
        $entry = $yv_utils->format_text(
                                        info   => $info,
                                        text   => $entry,
                                        escape => 0,
                                       );
        return "$entry\n";
    }

    if (ref($entry) eq 'ARRAY') {

        my @columns;

        foreach my $slot (@$entry) {

            my $text  = $slot->{text};
            my $width = $slot->{width} // 10;
            my $color = $slot->{color};
            my $align = $slot->{align} // 'left';

            if ($width =~ /^(\d+)%\z/) {
                $width = int(($term_width * $1) / 100);
            }

            $text =~ s/\*NO\*/$i+1/ge;

            $text = $yv_utils->format_text(
                                           info   => $info,
                                           text   => $text,
                                           escape => 0,
                                          );

            $text = clear_title($text);
            $text = adjust_width($text, $width, ($align eq 'right'));

            if (defined($color)) {
                $text = colored($text, $color);
            }

            push @columns, $text;
        }

        return (join(' ', @columns) . "\n");
    }

    die "ERROR: invalid custom layout format <<$entry>>\n";
}

# ... PRINT SUBROUTINES ... #

sub print_channels {
    my ($results) = @_;

    if (not $yv_utils->has_entries($results)) {
        warn_no_results("channel");
    }

    if ($opt{get_term_width}) {
        get_term_width();
    }

    my $url      = $results->{url};
    my $info     = $results->{results} // {};
    my $channels = $info->{items}      // [];

    my %table = map { $yv_utils->get_channel_id($_) => $_ } @$channels;

    if (@{$channels} and not exists($channels->[0]{statistics})) {

        my @channel_ids     = grep { defined } map { $yv_utils->get_channel_id($_) } @{$channels};
        my $content_details = $yv_obj->channel_from_id(join(',', @channel_ids), 'statistics,snippet,id');
        my $channel_details = $content_details->{results}{items};

        foreach my $entry (@$channel_details) {
            my $id = $yv_utils->get_channel_id($entry) // next;
            @{$table{$id}}{qw(statistics snippet id)} = @{$entry}{qw(statistics snippet id)};
        }
    }

    my @formatted;

    foreach my $i (0 .. $#{$channels}) {

        my $channel = $channels->[$i];
        my $entry   = $opt{custom_channel_layout_format};

        push @formatted, format_line_result($i, $entry, $channel);
    }

    if (@formatted) {
        print "\n" . join("", @formatted);
    }

    my @keywords = get_input_for_channels();

    my @for_search;
    foreach my $key (@keywords) {
        if ($key =~ /$valid_opt_re/) {

            my $opt = $1;

            if (
                general_options(
                                opt  => $opt,
                                sub  => __SUB__,
                                url  => $url,
                                res  => $channels,
                                info => $info,
                               )
              ) {
                ## ok
            }

            # :h, :help
            elsif ($opt =~ /^(?:h|help)\z/) {
                print $channels_help;
                press_enter_to_continue();
            }

            # :r, :return
            elsif ($opt =~ /^(?:r|return)\z/) {
                return;
            }

            # :i=i, :info=i
            elsif ($opt =~ /^(?:i|info)${digit_or_equal_re}(.*)/) {
                if (my @ids = get_valid_numbers($#{$channels}, $1)) {
                    foreach my $id (@ids) {
                        print_channel_info($channels->[$id]);
                    }
                    press_enter_to_continue();
                }
                else {
                    warn_no_thing_selected('playlist');
                }
            }

            # :pv=i, :popular=i
            elsif ($opt =~ /^(?:pv|popular)${digit_or_equal_re}(.*)/) {
                if (my @nums = get_valid_numbers($#{$channels}, $1)) {

                    foreach my $id (@nums) {

                        my $channel_id = $yv_utils->get_channel_id($channels->[$id]);
                        my $request    = $yv_obj->popular_videos($channel_id);

                        if ($yv_utils->has_entries($request)) {
                            print_videos($request);
                        }
                        else {
                            warn_no_results('popular video');
                        }
                    }
                }
                else {
                    warn_no_thing_selected('channel');
                }
            }

            # :p=i, :playlist=i, :up=i
            elsif ($opt =~ /^(?:p|l|playlists?|up)${digit_or_equal_re}(.*)/) {
                if (my @nums = get_valid_numbers($#{$channels}, $1)) {

                    foreach my $id (@nums) {

                        my $channel_id = $yv_utils->get_channel_id($channels->[$id]);
                        my $request    = $yv_obj->playlists($channel_id);

                        if ($yv_utils->has_entries($request)) {
                            print_playlists($request);
                        }
                        else {
                            warn_no_results('playlist');
                        }
                    }
                }
                else {
                    warn_no_thing_selected('channel');
                }
            }

            # :s=i, :save=i
            elsif ($opt =~ /^(?:s|save)${digit_or_equal_re}(.*)/) {
                if (my @nums = get_valid_numbers($#{$channels}, $1)) {
                    foreach my $id (@nums) {
                        my $channel_id    = $yv_utils->get_channel_id($channels->[$id]);
                        my $channel_title = $yv_utils->get_title($channels->[$id]);
                        save_channel_to_file($channel_id, $channel_title);
                    }
                }
                else {
                    warn_no_thing_selected('channel');
                }
            }

            # :sub=i, :subscribe=i
            elsif ($opt =~ /^(?:sub(?:scribe)?|S)${digit_or_equal_re}(.*)/) {
                if (my @nums = get_valid_numbers($#{$channels}, $1)) {
                    subscribe(map { $yv_utils->get_channel_id($channels->[$_]) } @nums);
                }
                else {
                    warn_no_thing_selected('video');
                }
            }

            # :unsub=i, unsubscribe=i
            elsif ($opt =~ /^(?:unsub(?:scribe)?)${digit_or_equal_re}(.*)/) {
                if (my @nums = get_valid_numbers($#{$channels}, $1)) {
                    unsubscribe(map { $yv_utils->get_channel_id($channels->[$_]) } @nums);
                }
                else {
                    warn_no_thing_selected('video');
                }
            }

            # :r=i, :rm=i, :remove=i
            elsif ($opt =~ /^(?:r|rm|remove)${digit_or_equal_re}(.*)/) {
                if (my @nums = get_valid_numbers($#{$channels}, $1)) {
                    remove_saved_channels(map { $yv_utils->get_channel_id($channels->[$_]) } @nums);
                }
                else {
                    warn_no_thing_selected('channel');
                }
            }
            else {
                warn_invalid('option', $opt);
            }
        }
        elsif (youtube_urls($key)) {
            ## ok
        }
        elsif (valid_num($key, $channels)) {
            print_videos($yv_obj->uploads($yv_utils->get_channel_id($channels->[$key - 1])));
        }
        else {
            push @for_search, $key;
        }
    }

    if (@for_search) {
        __SUB__->($yv_obj->search_channels(\@for_search));
    }

    __SUB__->(@_);
}

sub print_comments {
    my ($results, $videoID) = @_;

    if (not $yv_utils->has_entries($results)) {
        warn_no_results("comments");
    }

    my $url      = $results->{url};
    my $info     = $results->{results} // {};
    my $comments = $info->{items}      // [];

    my $i = 0;
    foreach my $comment (@{$comments}) {
        my $snippet     = (($comment->{snippet} // next)->{topLevelComment} // next)->{snippet};
        my $comment_age = $yv_utils->date_to_age($snippet->{publishedAt});

        printf(
               "\n%s (%s) commented:\n%s\n",
               colored($snippet->{authorDisplayName}, 'bold'),
               (
                $comment_age =~ /sec|min|hour|day/
                ? "$comment_age ago"
                : $yv_utils->format_date($snippet->{publishedAt})
               ),
               wrap_text(
                         i_tab => q{ } x 3,
                         s_tab => q{ } x 3,
                         text  => [$snippet->{textDisplay} // 'Empty comment...']
                        ),
              );

        if (exists $comment->{replies}) {
            foreach my $reply (reverse @{$comment->{replies}{comments}}) {
                my $reply_age = $yv_utils->date_to_age($reply->{snippet}{publishedAt});
                printf(
                       "\n   %s (%s) replied:\n%s\n",
                       colored($reply->{snippet}{authorDisplayName}, 'bold'),
                       (
                        $reply_age =~ /sec|min|hour|day/
                        ? "$reply_age ago"
                        : $yv_utils->format_date($reply->{snippet}{publishedAt})
                       ),
                       wrap_text(
                                 i_tab => q{ } x 6,
                                 s_tab => q{ } x 6,
                                 text  => [$reply->{snippet}{textDisplay} // 'Empty comment...']
                                ),
                      );
            }
        }
    }

    my @keywords = get_input_for_comments();

    foreach my $key (@keywords) {
        if ($key =~ /$valid_opt_re/) {

            my $opt = $1;

            if (
                general_options(
                                opt  => $opt,
                                sub  => __SUB__,
                                url  => $url,
                                res  => $comments,
                                info => $info,
                                mode => 'comments',
                                args => [$videoID],
                               )
              ) {
                ## ok
            }
            elsif ($opt =~ /^(?:h|help)\z/) {
                print $comments_help;
                press_enter_to_continue();
            }
            elsif ($opt =~ /^(?:c|comment)\z/) {
                if (authenticated()) {
                    require File::Temp;
                    my ($fh, $filename) = File::Temp::tempfile();
                    $yv_obj->proxy_system($ENV{EDITOR} // 'nano', $filename);
                    if ($?) {
                        warn colored("\n[!] Editor exited with a non-zero code. Unable to continue!", 'bold red') . "\n";
                    }
                    else {
                        my $comment = do { local (@ARGV, $/) = $filename; <> };
                        $comment =~ s/[^\s[:^cntrl:]]+//g;    # remove control characters

                        if (length($comment) and $yv_obj->comment_to_video_id($comment, $videoID)) {
                            print "\n:: Comment posted!\n";
                        }
                        else {
                            warn colored("\n[!] Your comment has NOT been posted!", 'bold red') . "\n";
                        }
                    }
                }
            }
            elsif ($opt =~ /^(?:r|return)\z/) {
                return;
            }
            else {
                warn_invalid('option', $opt);
            }
        }
        elsif (youtube_urls($key)) {
            ## ok
        }
        elsif (valid_num($key, $comments)) {
            print_videos($yv_obj->get_videos_from_username($comments->[$key - 1]{author}));
        }
        else {
            warn_invalid('keyword', $key);
        }
    }

    __SUB__->(@_);
}

sub save_channel_to_file {
    my ($channel_id, $channel_title) = @_;

    $channel_id // return;

    if ($channel_id = extract_channel_id($channel_id)) {
        if (not $yv_utils->is_channelID($channel_id)) {
            $channel_id = $yv_obj->channel_id_from_username($channel_id) // do {
                warn_invalid("username or channel ID", $channel_id);
                undef;
            };
        }

        if ($channel_id eq 'mine') {
            $channel_id = $yv_obj->my_channel_id() // do {
                warn_invalid("username or channel ID", $channel_id);
                undef;
            };
        }
    }

    $channel_id // return;

    if (not defined($channel_title)) {
        $channel_title = $yv_utils->get_title($yv_obj->channel_from_id($channel_id, 'snippet')->{results}{items}[0]);
    }

    say "\n:: Saving channel <<$channel_title>> (id: $channel_id) to file...";

    open(my $fh, '>>:utf8', $opt{youtube_users_file}) or do {
        warn "[!] Can't open file <<$opt{youtube_users_file}>> for appending: $!\n";
        return;
    };

    say $fh "$channel_id $channel_title";
    close $fh;

    say ":: Done.";
    return 1;
}

sub update_channel_file {
    my (%channels) = @_;

    open(my $fh, '>:utf8', $opt{youtube_users_file}) or do {
        warn "[!] Can't open file <<$opt{youtube_users_file}>> for writing: $!\n";
        return;
    };

    foreach my $key (sort { CORE::fc($channels{$a}) cmp CORE::fc($channels{$b}) } keys %channels) {
        say $fh "$key $channels{$key}";
    }

    close $fh;
}

sub remove_saved_channels {
    my (@channel_ids) = @_;

    open(my $fh, '<:utf8', $opt{youtube_users_file}) or do {
        warn "[!] Can't open file <<$opt{youtube_users_file}>> for reading: $!\n";
        return;
    };

    my %channels;

    while (defined(my $line = <$fh>)) {
        if ($line =~ /^([a-zA-Z0-9_-]+) (.+)/) {
            my ($channel_id, $channel_title) = ($1, $2);

            if ($yv_utils->is_channelID($channel_id)) {
                $channels{$channel_id} = $channel_title;
            }
            else {
                warn "[!] Invalid channel ID: $channel_id\n";
            }
        }
    }

    close $fh;

    my $removed = 0;

    foreach my $channel_id (@channel_ids) {
        if (exists $channels{$channel_id}) {
            say ":: Removing: $channel_id";
            delete $channels{$channel_id};
            ++$removed;
        }
        else {
            say ":: $channel_id is not a saved channel...";
        }
    }

    if ($removed > 0) {
        update_channel_file(%channels);
    }
}

sub get_results_from_list {
    my ($ids, %args) = @_;

    $args{page} //= $yv_obj->get_page;

    my @ids = @$ids;

    my $maxResults   = $yv_obj->get_maxResults;
    my $totalResults = scalar(@ids);

    if ($args{page} >= 1 and scalar(@ids) >= $maxResults) {

        @ids = grep { defined } @ids[($args{page} - 1) * $maxResults .. $args{page} * $maxResults - 1];

        if (!@ids) {
            warn_last_page()                                       if ($args{page} == 1 + sprintf('%0.f', 0.5 + $totalResults / $maxResults));
            return __SUB__->($ids, %args, page => $args{page} - 1) if ($args{page} > 1);
        }
    }

    my %results;
    my @entries;

    foreach my $id (@ids) {
        if (defined($args{callback})) {
            push @entries, $args{callback}($id);
        }
        else {
            push @entries, $yv_utils->local_video_snippet($id);
        }
    }

#<<<
    $results{items}         = \@entries;
    $results{pageInfo}      = {resultsPerPage => scalar(@entries), totalResults => $totalResults};
    $results{fromPage}      = sub { get_results_from_list($ids, %args, page => $_[0]) };
    $results{nextPageToken} = sub { get_results_from_list($ids, %args, page => ($args{page} + 1)) };
    $results{prevPageToken} = sub { get_results_from_list($ids, %args, page => (($args{page} > 1) ? ($args{page} - 1) : do { warn_first_page(); 1 })) };
#>>>

    scalar {results => \%results, url => undef};
}

sub extract_video_ids_from_playlist {
    my ($playlistID, $callback) = @_;

    $playlistID = get_valid_playlist_id($playlistID) // return;

    local $yv_obj->{maxResults} = 50;
    my $results = $yv_obj->videos_from_playlist_id($playlistID);

    while (1) {
        $yv_utils->has_entries($results) || last;

        my $url    = $results->{url};
        my $info   = $results->{results} // {};
        my $videos = $info->{items}      // [];

        foreach my $video (@$videos) {
            my $video_id = $yv_utils->get_video_id($video);
            $callback->($video_id) if defined($video_id);
        }

        $results = $yv_obj->from_page_token($url, $info->{nextPageToken} || last);
    }

    return 1;
}

sub save_video_to_file {
    my ($videoID) = @_;

    say ":: Saving video ID <<$videoID>> to file...";

    open(my $fh, '>>', $opt{saved_videos_file}) or do {
        warn "[!] Can't open file <<$opt{saved_videos_file}>> for appending: $!";
        return;
    };

    say {$fh} $videoID;

    close $fh;
}

sub remove_saved_videos {
    my (@video_ids) = @_;

    @video_ids || return;

    my @ids = reverse $yv_utils->read_lines_from_file($opt{saved_videos_file});

    my %removed;
    @removed{@video_ids} = ();

    my @filtered = grep { not exists $removed{$_} } @ids;

    if (scalar(@filtered) != scalar(@ids)) {

        say ":: Removing ", scalar(@ids) - scalar(@filtered), " saved videos...";

        open(my $fh, '>', $opt{saved_videos_file}) or do {
            warn "[!] Can't open file <<$opt{saved_videos_file}>> for writing: $!";
            return;
        };

        say {$fh} join("\n", @filtered);
        close $fh;
    }
    else {
        say ":: No video has been removed...";
    }
}

sub save_playlist_to_file {
    my ($playlistID, $title) = @_;

    $playlistID // return;

    if (not defined($title)) {
        $title = $yv_utils->get_title($yv_obj->playlist_from_id($playlistID, 'snippet')->{results}{items}[0]);
    }

    if (not defined($title)) {
        warn "[!] Unable to determine the title of the playlist...\n";
        return;
    }

    my $basename = $yv_utils->make_local_playlist_filename($title, $playlistID);
    my $filename = catfile($local_playlists_dir, $basename);

    say ":: Saving playlist <<$title>> (id: $playlistID) to file...";

    if (-e $filename) {
        warn "[!] File <<$filename>> already exists!\n";
        return;
    }

    open(my $fh, '>', $filename) or do {
        warn "[!] Can't open file <<$filename>> for writing: $!";
        return;
    };

    extract_video_ids_from_playlist($playlistID, sub { say $fh $_[0] });
    close $fh;

    say ":: Done.";
    return 1;
}

sub print_local_playlist {
    my ($name) = @_;

    $name //= '';

    require File::Basename;

    my @playlist_files = $yv_utils->get_local_playlist_filenames($local_playlists_dir);
    my $regex          = qr/\Q$name\E/i;

    if ($name eq '') {
        my $results = get_results_from_list(
            \@playlist_files,
            callback => sub {
                my ($id) = @_;
                $yv_utils->local_playlist_snippet($id);
            }
        );
        return print_playlists($results);
    }

    foreach my $file (@playlist_files) {

        if (File::Basename::basename($file) =~ $regex or $file eq $name) {

            my @ids = $yv_utils->read_lines_from_file($file);

            if ($file eq $opt{saved_videos_file} or $file eq $opt{watch_history_file}) {
                ## ok
            }
            else {
                @ids = reverse @ids;
            }

            @ids || next;
            return print_videos(get_results_from_list(\@ids));
        }
    }

    warn_no_thing_selected('playlist');
    return 0;
}

sub print_watched_videos {

    my @ids;

    if ($opt{watch_history}) {
        @ids = $yv_utils->read_lines_from_file($opt{watch_history_file});
    }

    if (scalar(@ids) == 0) {
        @ids = sort keys %WATCHED_VIDEOS;
    }

    print_videos(get_results_from_list(\@ids));
}

sub print_saved_videos {
    my @ids = $yv_utils->read_lines_from_file($opt{saved_videos_file});
    print_videos(get_results_from_list(\@ids));
}

sub print_local_subscription_videos {

    state $t0 = time;
    state $d0 = $t0;

    # Reuse the subscription file if it's less than 10 minutes old
    if (    $t0 != $d0
        and (time - $t0 <= 600)
        and (-f $local_subscription_videos_file)
        and (-M $local_subscription_videos_file) < (-M $opt{youtube_users_file})) {
        return print_local_playlist($local_subscription_videos_file);
    }

    $t0 = time + 1;

    my @channels    = $yv_utils->read_channels_from_file($opt{youtube_users_file});
    my @channel_ids = map { $_->[0] } @channels;

    my @items;

    while (@channel_ids) {
        my $results = $yv_obj->channel_from_id(join(',', splice(@channel_ids, 0, 50)), 'statistics,id')->{results}{items};
        if (ref($results) eq 'ARRAY') {
            push @items, @{$results};
        }
    }

    my $prev_subscriptions_data = {channel_data => {},};

    if (-f $local_subscriptions_data_file and not -z _) {
        require Storable;
        $prev_subscriptions_data = eval { Storable::retrieve($local_subscriptions_data_file) } // {};
    }

    my $subscriptions_data = {channel_data => {map { $_->{id} => $_ } @items}};

    foreach my $info (@items) {

        my $prev_info = $prev_subscriptions_data->{channel_data}{$info->{id}};

        if (   not defined($prev_info)
            or not exists($prev_info->{videos})
            or $yv_utils->get_channel_video_count($info) != $yv_utils->get_channel_video_count($prev_info)) {

            local $yv_obj->{maxResults} = $opt{subscription_videos_per_channel} || 10;
            my $uploads = $yv_obj->uploads($info->{id});

            if ($yv_utils->has_entries($uploads)) {
                push @{$info->{videos}}, @{$uploads->{results}{items} // []};
                @{$info->{videos}} = do {
                    my %seen;
                    grep { !$seen{$yv_utils->get_video_id($_)}++ } @{$info->{videos}};
                };
            }
        }
        else {
            $info->{videos} = $prev_info->{videos};
        }
    }

    if (@items) {
        require Storable;
        Storable::store($subscriptions_data, $local_subscriptions_data_file);
    }

    my @subscription_videos =
      sort { $yv_utils->compare_published_dates($b, $a) }
      map  { @{$_->{videos}} }
      grep { ref($_->{videos}) eq 'ARRAY' } @items;

    my @video_ids = map { $yv_utils->get_video_id($_) } @subscription_videos;

    if (open(my $fh, '>', $local_subscription_videos_file)) {
        say {$fh} join("\n", @video_ids);
        close $fh;
    }
    else {
        warn "Can't open file <<$local_subscription_videos_file>> for write: $!";
    }

    print_videos(get_results_from_list(\@video_ids));
}

sub print_local_channels {
    my ($name) = @_;

    $name //= '';

    my @users;
    my $file = $opt{youtube_users_file};

    if (-e $file) {
        @users = $yv_utils->read_channels_from_file($file);
    }
    else {
        @users = $yv_utils->default_channels;
    }

    my $regex = qr/\Q$name\E/i;

    if ($name eq '') {
        my $results = get_results_from_list(
            \@users,
            callback => sub {
                my ($entry) = @_;
                my ($id, $name) = @$entry;
                $yv_utils->local_channel_snippet($id, $name);
            }
        );
        return print_channels($results);
    }

    foreach my $user (@users) {

        my ($channel_id, $channel_name) = @$user;

        if ($channel_id eq $name or $channel_name =~ $regex) {
            return print_videos($yv_obj->uploads($channel_id));
        }
    }

    warn_no_thing_selected('channel');
    return 0;
}

sub print_categories {
    my ($results) = @_;

    return if ref($results) ne 'HASH';
    my $categories = $results->{items};
    return if ref($categories) ne 'ARRAY';

    my $i = 0;
    print "\n" if @{$categories};

    # Filter out nonassignable categories
    @$categories = grep { $_->{snippet}{assignable} } @$categories;

    foreach my $category (@{$categories}) {
        printf("%s. %-40s (id: %s)\n", colored(sprintf('%2d', ++$i), 'bold'), $yv_utils->get_title($category), $category->{id});
    }

    my @keywords = get_input_for_categories();

    foreach my $key (@keywords) {
        if ($key =~ /$valid_opt_re/) {

            my $opt = $1;

            if (
                general_options(
                                opt => $opt,
                                sub => __SUB__,
                                res => $results,
                               )
              ) {
                ## ok
            }
            elsif ($opt =~ /^(?:h|help)\z/) {
                print $general_help;
                press_enter_to_continue();
            }
            elsif ($opt =~ /^(?:r|return)\z/) {
                return;
            }
            else {
                warn_invalid('option', $opt);
            }
        }
        elsif (youtube_urls($key)) {
            ## ok
        }
        elsif (valid_num($key, $categories)) {
            my $category = $categories->[$key - 1];
            my $cat_id   = $category->{id};
            my $videos   = $yv_obj->videos_from_category($cat_id);
            print_videos($videos);
        }
        else {
            warn_invalid('keyword', $key);
        }
    }

    __SUB__->(@_);
}

sub print_playlists {
    my ($results, %args) = @_;

    if (not $yv_utils->has_entries($results)) {
        warn_no_results("playlist");
    }

    if ($opt{get_term_width}) {
        get_term_width();
    }

    my $url       = $results->{url};
    my $info      = $results->{results} // {};
    my $playlists = $info->{items}      // [];

    my %table = map { $yv_utils->get_playlist_id($_) => $_ } @$playlists;

    if (@{$playlists} and not exists($playlists->[0]{contentDetails})) {

        my @playlist_ids     = grep { defined } map { $yv_utils->get_playlist_id($_) } @{$playlists};
        my $content_details  = $yv_obj->playlist_from_id(join(',', @playlist_ids), 'contentDetails');
        my $playlist_details = $content_details->{results}{items};

        foreach my $entry (@$playlist_details) {
            my $id = $yv_utils->get_playlist_id($entry) // next;
            @{$table{$id}}{qw(contentDetails)} = @{$entry}{qw(contentDetails)};
        }
    }

    my @formatted;

    foreach my $i (0 .. $#{$playlists}) {

        my $playlist = $playlists->[$i];
        my $entry    = $opt{custom_playlist_layout_format};

        push @formatted, format_line_result($i, $entry, $playlist);
    }

    if (@formatted) {
        print "\n" . join("", @formatted);
    }

    state @keywords;
    if ($args{auto}) { }    # do nothing...
    else {
        @keywords = get_input_for_playlists();
        if (scalar(@keywords) == 0) {
            __SUB__->(@_);
        }
    }

    my $contains_keywords = grep { /$non_digit_or_opt_re/ } @keywords;

    my @for_search;
    foreach my $key (@keywords) {
        if ($key =~ /$valid_opt_re/) {

            my $opt = $1;

            if (
                general_options(
                                opt  => $opt,
                                sub  => __SUB__,
                                url  => $url,
                                res  => $playlists,
                                info => $info,
                                mode => 'playlists',
                               )
              ) {
                ## ok
            }
            elsif ($opt =~ /^(?:h|help)\z/) {
                print $playlists_help;
                press_enter_to_continue();
            }
            elsif ($opt =~ /^(?:r|return)\z/) {
                return;
            }

            # :s=i, :save=i
            elsif ($opt =~ /^(?:s|save)${digit_or_equal_re}(.*)/) {
                if (my @ids = get_valid_numbers($#{$playlists}, $1)) {
                    foreach my $id (@ids) {
                        my $playlist   = $playlists->[$id];
                        my $playlistID = $yv_utils->get_playlist_id($playlist);
                        my $title      = $yv_utils->get_title($playlist);
                        save_playlist_to_file($playlistID, $title);
                    }
                }
                else {
                    warn_no_thing_selected('playlist');
                }
            }

            # :r=i, :rm=i, :remove=i
            elsif ($opt =~ /^(?:r|rm|remove)${digit_or_equal_re}(.*)/) {
                if (my @nums = get_valid_numbers($#{$playlists}, $1)) {

                    foreach my $i (@nums) {
                        my $id    = $yv_utils->get_playlist_id($playlists->[$i]);
                        my $title = $yv_utils->get_title($playlists->[$i]);

                        if ($id =~ m{^/} and -f $id) {
                            say ":: Removing local playlist <<$title>>";
                            say(unlink($id) ? ":: Done." : ":: Error: $!");
                        }
                        else {
                            say ":: Playlist <<$title>> is not saved locally";
                        }
                    }
                }
                else {
                    warn_no_thing_selected('playlist');
                }
            }

            # :i=i, :info=i
            elsif ($opt =~ /^(?:i|info)${digit_or_equal_re}(.*)/) {
                if (my @ids = get_valid_numbers($#{$playlists}, $1)) {
                    foreach my $id (@ids) {
                        print_playlist_info($playlists->[$id]);
                    }
                    press_enter_to_continue();
                }
                else {
                    warn_no_thing_selected('playlist');
                }
            }

            # :p=i, :playlist=i, :up=i
            elsif ($opt =~ /^(?:p|playlists?|up)${digit_or_equal_re}(.*)/) {
                if (my @nums = get_valid_numbers($#{$playlists}, $1)) {
                    foreach my $id (@nums) {
                        my $request = $yv_obj->playlists($yv_utils->get_channel_id($playlists->[$id]));
                        if ($yv_utils->has_entries($request)) {
                            print_playlists($request);
                        }
                        else {
                            warn_no_results('playlist');
                        }
                    }
                }
                else {
                    warn_no_thing_selected('playlist');
                }
            }

            # :pp=i
            elsif ($opt =~ /^pp${digit_or_equal_re}(.*)/) {
                if (my @ids = get_valid_numbers($#{$playlists}, $1)) {
                    foreach my $playlist (@{$playlists}[@ids]) {

                        my $id = $yv_utils->get_playlist_id($playlist);

                        if ($id =~ m{^/}) {    # local playlist
                            my @ids = reverse $yv_utils->read_lines_from_file($id);
                            apply_input_arguments(["--id=" . join(",", @ids)]) if @ids;
                        }
                        else {
                            apply_input_arguments(["--pp=$id"]);
                        }
                    }
                }
                else {
                    warn_no_thing_selected('playlist');
                }
            }
            else {
                warn_invalid('option', $opt);
            }
        }
        elsif (youtube_urls($key)) {
            ## ok
        }
        elsif (valid_num($key, $playlists) and not $contains_keywords) {

            my $id = $yv_utils->get_playlist_id($playlists->[$key - 1]);

            if ($args{return_playlist_id}) {
                return $id;
            }

            if ($id =~ m{^/}) {    # local playlist
                print_local_playlist($id);
            }
            else {
                get_and_print_videos_from_playlist($id);
            }
        }
        else {
            push @for_search, $key;
        }
    }

    if (@for_search) {
        __SUB__->($yv_obj->search_playlists(\@for_search));
    }

    __SUB__->(@_);
}

sub compile_regex {
    my ($value) = @_;

    #~ $value =~ s{^(?<quote>['"])(?<regex>.+)\g{quote}$}{$+{regex}}s;

    my $re = eval { use re qw(eval); qr/$value/i };

    if ($@) {
        warn_invalid("regex", $@);
        return;
    }

    return $re;
}

sub parse_page_number {
    my ($page_number, $info) = @_;

    $page_number // return 1;

    if ($page_number =~ /^[0-9]+\z/) {
        ## ok
    }
    elsif ($page_number =~ /last|end/) {

        if (ref($info->{pageInfo}) eq 'HASH') {

            my $total    = $info->{pageInfo}{totalResults};
            my $per_page = $info->{pageInfo}{resultsPerPage};

            # In search results, restrict total to 500. Otherwise, it fails.
            if ($total >= 1000000) {
                $total = 500;
            }

            $page_number = int($total / $per_page);
            $page_number += 1 if ($total % $per_page != 0);
            $page_number = 1  if ($page_number <= 0);
        }
    }
    elsif ($page_number =~ /first|beg/) {
        $page_number = 1;
    }

    return $page_number;
}

sub get_range_numbers {
    my ($first, $second) = @_;

    return (
            $first > $second
            ? (reverse($second .. $first))
            : ($first .. $second)
           );
}

sub get_valid_numbers {
    my ($max, $input) = @_;

    my @output;
    foreach my $id (split(/[,\s]+/, $input)) {
        push @output,
            $id =~ /$range_num_re/ ? get_range_numbers($1, $2)
          : $id =~ /^[0-9]{1,2}\z/ ? $id
          :                          next;
    }

    return grep { $_ >= 0 and $_ <= $max } map { $_ - 1 } @output;
}

sub get_streaming_url {
    my ($video_id) = @_;

    my ($urls, $captions, $info) = $yv_obj->get_streaming_urls($video_id);

    if (not defined $urls) {
        return scalar {};
    }

    # Download the closed-captions
    my $srt_file;
    if (ref($captions) eq 'ARRAY' and @$captions and $opt{get_captions} and not $opt{novideo}) {
        require WWW::YoutubeViewer::GetCaption;

        my $languages = $opt{srt_languages};

        if (ref($languages) ne 'ARRAY') {
            $languages = [grep { /[a-z]/i } split(/\s*,\s*/, $languages)];
        }

        my $yv_cap = WWW::YoutubeViewer::GetCaption->new(
                                                         auto_captions => $opt{auto_captions},
                                                         captions_dir  => $opt{cache_dir},
                                                         captions      => $captions,
                                                         languages     => $languages,
                                                         yv_obj        => $yv_obj,
                                                        );
        $srt_file = $yv_cap->save_caption($video_id);
    }

    require WWW::YoutubeViewer::Itags;
    state $yv_itags = WWW::YoutubeViewer::Itags->new();

    # Include split A/V videos
    my $split_videos = 1;

    # Exclude split-videos when no video output is required
    if ($opt{novideo} or not $opt{split_videos}) {
        $split_videos = 0;
    }
    elsif ($opt{download_video}) {
        $split_videos = $opt{merge_into_mkv} ? 1 : 0;
    }

    my ($streaming, $resolution) = $yv_itags->find_streaming_url(
        urls       => $urls,
        resolution => ($opt{novideo} ? 'audio' : $opt{resolution}),

        hfr           => $opt{hfr},
        ignore_av1    => $opt{ignore_av1},
        prefer_m4a    => $opt{prefer_m4a},
        audio_quality => $opt{audio_quality},

        split_videos   => $split_videos,
        dash_segmented => ($opt{download_video} ? 0 : $opt{dash_segmented}),

        ignored_projections => $opt{ignored_projections},
    );

    return {
            streaming  => $streaming,
            srt_file   => $srt_file,
            info       => $info,
            resolution => $resolution,
           };
}

sub download_from_url {
    my ($info, $output_filename) = @_;

    my $url = $info->{url};

    # Download with yt-dlp / youtube-dl
    if ($opt{ytdl} and $opt{download_with_ytdl} and defined($info->{_youtube_url}) and defined($info->{itag})) {

        # TODO: take into account the preferred audio quality and format and video resolution
        # and format when falling back (i.e. when yt-dlp cannot find the itag that we want)
        my $cmd = join(' ',
                       $opt{ytdl_cmd},
                       ($info->{wkad} ? () : ('-f', $info->{itag} . ($info->{type} =~ m{^audio/} ? '/bestaudio' : '/bestvideo'))),
                       quotemeta($info->{_youtube_url}),
                       '-o', quotemeta("$output_filename.part"));

        if ($yv_obj->get_debug) {
            say "-> Command: $cmd";
        }

        $yv_obj->proxy_system($cmd);
        return if $?;
        rename("$output_filename.part", $output_filename) or return undef;
        return $output_filename;
    }

    # Download with wget
    if ($opt{download_with_wget}) {
        my $cmd = join(' ', $opt{wget_cmd}, '-c', '-t', '10', '--waitretry=3', quotemeta($url), '-O', quotemeta("$output_filename.part"));
        $yv_obj->proxy_system($cmd);
        return if $?;
        rename("$output_filename.part", $output_filename) or return undef;
        return $output_filename;
    }

    state $lwp_dl = which_command('lwp-download');

    # Download with lwp-download
    if (defined($lwp_dl)) {
        my @cmd = ($lwp_dl, $url, "$output_filename.part");
        $yv_obj->proxy_system(@cmd);
        if ($? == 256 and !defined(fileno(STDOUT))) {    # lwp-download bug
            ## ok
        }
        else {
            return if $?;
        }
        rename("$output_filename.part", $output_filename) or return undef;
        return $output_filename;
    }

    # Download with LWP::UserAgent
    require LWP::UserAgent;

    my $lwp = LWP::UserAgent->new(show_progress => 1,
                                  agent         => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:120.0) Gecko/20100101 Firefox/120.0',);

    $lwp->proxy(['http', 'https'], $yv_obj->get_http_proxy)
      if defined($yv_obj->get_http_proxy);

    my $resp = eval { $lwp->mirror($url, "$output_filename.part") };

    if ($@ =~ /\bread timeout\b/i or not defined($resp) or not $resp->is_success) {
        warn colored("\n[!] Encountered an error while downloading... Trying again...", 'bold red') . "\n\n";

        if (defined(my $wget_path = which_command('wget'))) {
            $CONFIG{wget_cmd}           = $wget_path;
            $CONFIG{download_with_wget} = 1;
            dump_configuration($config_file);
        }
        else {
            warn colored("[!] Please install `wget` and try again...", 'bold red') . "\n\n";
        }

        unlink("$output_filename.part");
        return download_from_url($info, $output_filename);
    }

    rename("$output_filename.part", $output_filename) or return undef;
    return $output_filename;
}

sub download_video {
    my ($streaming, $info) = @_;

    my $video_filename = $yv_utils->format_text(
                                                streaming => $streaming,
                                                info      => $info,
                                                text      => $opt{video_filename_format},
                                                escape    => 0,
                                                fat32safe => $opt{fat32safe},
                                               );

    $video_filename =~ s/\h*:+\h*/ - /g;    # replace colons (":") with dashes ("-")

    my $naked_filename = $video_filename =~ s/\.\w+\z//r;

    my $mkv_filename   = "$naked_filename.mkv";
    my $srt_filename   = "$naked_filename.srt";
    my $audio_filename = "$naked_filename - audio";

    my $video_info = $streaming->{streaming};
    my $audio_info = $streaming->{streaming}{__AUDIO__};

    my $video_id = $yv_utils->format_text(
                                          streaming => $streaming,
                                          info      => $info,
                                          text      => '*ID*',
                                          escape    => 0
                                         );

    $video_info->{_youtube_url} = sprintf("https://youtube.com/watch?v=%s", $video_id);

    if ($audio_info) {
        $audio_filename .= "." . $yv_utils->extension($audio_info->{type});
        $audio_info->{_youtube_url} = $video_info->{_youtube_url};
    }

    if (not -d $opt{downloads_dir}) {
        require File::Path;
        if (not eval { File::Path::make_path($opt{downloads_dir}) }) {
            warn colored("\n[!] Can't create directory '$opt{downloads_dir}': $1", 'bold red') . "\n";
        }
    }

    if (not -d $opt{downloads_dir}) {
        warn colored("\n[!] Can't write into directory '$opt{downloads_dir}': $!", 'bold red') . "\n";
        $opt{downloads_dir} = (-d curdir()) ? curdir() : (-d $ENV{HOME}) ? $ENV{HOME} : return;
        warn colored("[!] Video will be downloaded into directory: $opt{downloads_dir}", 'bold red') . "\n";
    }

    $mkv_filename   = catfile($opt{downloads_dir}, $mkv_filename);
    $srt_filename   = catfile($opt{downloads_dir}, $srt_filename);
    $audio_filename = catfile($opt{downloads_dir}, $audio_filename);
    $video_filename = catfile($opt{downloads_dir}, $video_filename);

    if ($opt{skip_if_exists} and -e $mkv_filename) {
        $video_filename = $mkv_filename;
        say ":: File `$mkv_filename` already exists. Skipping...";
    }
    else {
        if ($opt{skip_if_exists} and -e $video_filename) {
            say ":: File `$video_filename` already exists. Skipping...";
        }
        else {
            $video_filename = download_from_url($video_info, $video_filename) // return;
        }

        if ($opt{skip_if_exists} and -e $audio_filename) {
            say ":: File `$audio_filename` already exists. Skipping...";
        }
        elsif ($audio_info) {
            $audio_filename = download_from_url($audio_info, $audio_filename) // return;
        }
    }

    my @merge_files = ($video_filename);

    if ($audio_info) {
        push @merge_files, $audio_filename;
    }

    if (    $opt{merge_with_captions}
        and defined($streaming->{srt_file})
        and -f $streaming->{srt_file}) {
        push @merge_files, $streaming->{srt_file};
    }

    if (    $opt{merge_into_mkv}
        and scalar(@merge_files) > 1
        and scalar(grep { -f $_ } @merge_files) == scalar(@merge_files)
        and not -e $mkv_filename) {

        say ":: Merging into MKV...";

        my $ffmpeg_cmd  = $opt{ffmpeg_cmd};
        my $ffmpeg_args = $opt{merge_into_mkv_args};

        if (my @srt_files = grep { /\.srt\z/ } @merge_files) {
            my $srt_file = $srt_files[0];
            require File::Basename;
            if (File::Basename::basename($srt_file) =~ m{^.{11}_([a-z]{2,4})}i) {
                my $lang_code = $1;
                $ffmpeg_args .= " -metadata:s:s:0 language=$lang_code";
            }
        }

        my $merge_command =
          join(' ', $ffmpeg_cmd, (map { "-i \Q$_\E" } @merge_files), $ffmpeg_args, "\Q$mkv_filename\E");

        if ($yv_obj->get_debug) {
            say "-> Command: $merge_command";
        }

        $yv_obj->proxy_system($merge_command);

        if ($? == 0 and -e $mkv_filename) {
            unlink @merge_files;
            $video_filename = $mkv_filename;
        }
        elsif ($? != 0) {    # ffmpeg failed
            if (-e $mkv_filename) {    # probably due to not enough space
                unlink $mkv_filename;    # remove the mkv file
            }
            return;
        }
    }

    # Convert the downloaded video
    if (defined $opt{convert_to}) {

        my $convert_filename = catfile($opt{downloads_dir}, "$naked_filename.$opt{convert_to}");
        my $convert_cmd      = $opt{convert_cmd};

        my %table = (
                     'IN'  => $video_filename,
                     'OUT' => $convert_filename,
                    );

        my $regex = do {
            local $" = '|';
            qr/\*(@{[keys %table]})\*/;
        };

        $convert_cmd =~ s/$regex/\Q$table{$1}\E/g;
        say $convert_cmd if $yv_obj->get_debug;

        $yv_obj->proxy_system($convert_cmd);

        if ($? == 0) {

            if (not $opt{keep_original_video}) {
                unlink $video_filename
                  or warn colored("\n[!] Can't unlink file '$video_filename': $!", 'bold red') . "\n\n";
            }

            $video_filename = $convert_filename if -e $convert_filename;
        }
    }

    # Play the download video
    if ($opt{download_and_play}) {

        local $streaming->{streaming}{url}       = '';
        local $streaming->{streaming}{__AUDIO__} = undef;
        local $streaming->{srt_file}             = undef if ($opt{merge_into_mkv} && $opt{merge_with_captions});

        my $command = get_player_command($streaming, $info);
        say "-> Command: ", $command if $yv_obj->get_debug;

        $yv_obj->proxy_system(join(q{ }, $command, quotemeta($video_filename)));

        # Remove it afterwards
        if ($? == 0 and $opt{remove_played_file}) {
            unlink $video_filename
              or warn colored("\n[!] Can't unlink file '$video_filename': $!", 'bold red') . "\n\n";
        }
    }

    # Copy the .srt file to downloads-dir
    if (    $opt{copy_caption}
        and -e $video_filename
        and defined($streaming->{srt_file})
        and -e $streaming->{srt_file}) {

        my $from = $streaming->{srt_file};
        my $to   = $srt_filename;

        require File::Copy;
        File::Copy::cp($from, $to);
    }

    return 1;
}

sub save_watched_video {
    my ($video_id) = @_;

    if (not exists $WATCHED_VIDEOS{$video_id}) {
        if ($opt{autolike_watched}) {
            rate_videos('like', $video_id);
        }
    }

    $WATCHED_VIDEOS{$video_id} = 1;

    if ($opt{watch_history}) {
        open(my $fh, '>>', $opt{watch_history_file}) or return;
        say {$fh} $video_id;
        close $fh;
    }

    return 1;
}

sub get_player_command {
    my ($streaming, $video) = @_;

    my %player_args = (%PLAYER_ARGS);
    my $player      = $opt{video_players}{$opt{video_player_selected}};

    if (ref($player) ne 'HASH') {
        die ":: The selected video player does not exist! Check the configuration file.";
    }

    $player_args{fullscreen} = $opt{fullscreen} ? $player->{fs}      : undef;
    $player_args{novideo}    = $opt{novideo}    ? $player->{novideo} : undef;
    $player_args{arguments}  = $player->{arg};

    my $cmd = join(
        q{ },
        (
            # Video player
            $player->{cmd},

            (    # Audio file (https://)
              (ref($streaming->{streaming}{__AUDIO__}) eq 'HASH' && defined($player->{audio}))
              ? $player->{audio}
              : ()
            ),

            (    # Subtitle file (.srt)
              (defined($streaming->{srt_file}) && defined($player->{srt}))
              ? $player->{srt}
              : ()
            ),

            # Rest of the arguments
            (grep { defined($_) and /\S/ } values %player_args)
        )
    );

    my $has_video = $cmd =~ /\*(?:VIDEO|URL)\*/;

    $cmd = $yv_utils->format_text(
                                  streaming => $streaming,
                                  info      => $video,
                                  text      => $cmd,
                                  escape    => 1,
                                 );

    if ($streaming->{streaming}{url} =~ m{^https://www\.youtube\.com/watch\?v=}) {
        $cmd =~ s{\s*--no-ytdl\b}{ }g;
    }

    $has_video ? $cmd : join(' ', $cmd, quotemeta($streaming->{streaming}{url}));
}

sub autoplay {
    my $video_id = get_valid_video_id(shift) // return;

    my %seen;    # make sure we don't get stuck in a loop
    local $yv_obj->{maxResults} = 10;

    if ($opt{shuffle}) {
        require List::Util;
    }

    while (1) {
        $seen{$video_id} = 1;
        get_and_play_video_ids($video_id) || return;

        my $related       = $yv_obj->related_to_videoID($video_id);
        my @video_ids     = grep { not $seen{$_} } map { $yv_utils->get_video_id($_) } @{$related->{results}{items}};
        my $prev_video_id = $video_id;

        shift(@video_ids);    # the first video seems to not be playable

        # Find the next playable video
        foreach my $id ($opt{shuffle} ? List::Util::shuffle(@video_ids) : @video_ids) {

            my $info = $yv_obj->video_details($id, VIDEO_PART);
            $yv_utils->has_entries($info) or next;

            my $streaming = get_streaming_url($id);

            if (defined($streaming->{info}{status})
                and $streaming->{info}{status} =~ /(?:error|fail)/i) {
                next;
            }

            $video_id = $id;
            last;
        }

        # No new video was found...
        if ($video_id eq $prev_video_id) {
            return;
        }
    }

    return 1;
}

sub play_videos {
    my ($videos) = @_;

    foreach my $video (@{$videos}) {

        my $video_id = $yv_utils->get_video_id($video);

        if ($opt{autoplay_mode}) {
            local $opt{autoplay_mode} = 0;
            autoplay($video_id);
            next;
        }

        # Ignore already watched videos
        if (exists($WATCHED_VIDEOS{$video_id}) and $opt{skip_watched}) {
            say ":: Already watched video (ID: $video_id)... Skipping...";
            next;
        }

        if (defined($opt{max_seconds}) and $opt{max_seconds} >= 0) {
            next if $yv_utils->get_duration($video) > $opt{max_seconds};
        }

        if (defined($opt{min_seconds}) and $opt{min_seconds} >= 0) {
            next if $yv_utils->get_duration($video) < $opt{min_seconds};
        }

        my $streaming = get_streaming_url($video_id);

        if (ref($streaming->{streaming}) ne 'HASH') {
            warn colored("[!] No streaming URL has been found...", 'bold red') . "\n";
            next;
        }

        if (   !defined($streaming->{streaming}{url})
            and defined($streaming->{info}{status})
            and $streaming->{info}{status} =~ /(?:error|fail)/i) {
            warn colored("[!] Error on: ", 'bold red') . sprintf($CONFIG{youtube_video_url}, $video_id) . "\n";
            warn colored(":: Reason: ",    'bold red') . $streaming->{info}{reason} =~ tr/+/ /r . "\n\n";
        }

        # Dump metadata information
        if (defined($opt{dump})) {

            my $file = $video_id . '.' . $opt{dump};
            open(my $fh, '>:utf8', $file)
              or die "Can't open file `$file' for writing: $!";

            local $video->{streaming} = $streaming;

            if ($opt{dump} eq 'json') {
                require JSON;
                print {$fh} JSON->new->pretty(1)->encode($video);
            }
            elsif ($opt{dump} eq 'perl') {
                require Data::Dump;
                print {$fh} Data::Dump::pp($video);
            }

            close $fh;
        }

        if ($opt{download_video}) {
            print_video_info($video);
            if (not download_video($streaming, $video)) {
                return;
            }
            save_watched_video($video_id);
        }
        elsif (length($opt{extract_info})) {
            my $fh = $opt{extract_info_fh} // \*STDOUT;
            say {$fh}
              $yv_utils->format_text(
                                     streaming => $streaming,
                                     info      => $video,
                                     text      => $opt{extract_info},
                                     escape    => $opt{escape_info},
                                     fat32safe => $opt{fat32safe},
                                    );
        }
        else {
            print_video_info($video);
            my $command = get_player_command($streaming, $video);

            if ($yv_obj->get_debug) {
                say "-> Resolution: $streaming->{resolution}";
                say "-> Video itag: $streaming->{streaming}{itag}";
                say "-> Audio itag: $streaming->{streaming}{__AUDIO__}{itag}" if exists $streaming->{streaming}{__AUDIO__};
                say "-> Video type: $streaming->{streaming}{type}";
                say "-> Audio type: $streaming->{streaming}{__AUDIO__}{type}" if exists $streaming->{streaming}{__AUDIO__};
                say "-> Command: $command";
            }

            $yv_obj->proxy_system($command);    # execute the video player

            if ($? and $? != 512) {
                $opt{auto_next_page} = 0;
                return;
            }

            save_watched_video($video_id);
        }

        press_enter_to_continue() if $opt{confirm};
    }

    return 1;
}

sub play_videos_matched_by_regex {
    my %args = @_;

    my $key    = $args{key};
    my $regex  = $args{regex};
    my $videos = $args{videos};

    my $sub = \&{'WWW::YoutubeViewer::Utils' . '::' . 'get_' . $key};

    if (not defined &$sub) {
        warn colored("\n[!] Invalid key: <$key>.", 'bold red') . "\n";
        return;
    }

    if (defined(my $re = compile_regex($regex))) {
        if (my @nums = grep { $yv_utils->$sub($videos->[$_]) =~ /$re/ } 0 .. $#{$videos}) {
            if (not play_videos([@{$videos}[@nums]])) {
                return;
            }
        }
        else {
            warn colored("\n[!] No video <$key> matched by the regex: $re", 'bold red') . "\n";
            return;
        }
    }

    return 1;
}

sub print_playlist_info {
    my ($playlist) = @_;

    my $hr = '-' x ($opt{get_term_width} ? get_term_width() : $term_width);

    printf(
           "\n%s\n%s\n%s\n",
           _bold_color('=> Description'),
           $hr,
           wrap_text(
                     i_tab => q{},
                     s_tab => q{},
                     text  => [$yv_utils->get_description($playlist) || 'No description available...']
                    ),
          );

    my $id = $yv_utils->get_playlist_id($playlist);

    if ($id =~ m{^/}) {
        ## local playlist
    }
    else {
        say STDOUT $hr, "\n", _bold_color('=> URL: '), sprintf("https://www.youtube.com/playlist?list=%s", $id);
    }

    my $title        = $yv_utils->get_title($playlist);
    my $title_length = length($title);
    my $rep          = ($term_width - $title_length) / 2 - 4;

    $rep = 0 if $rep < 0;

    print(
          "$hr\n",
          q{ } x $rep => (_bold_color("=>> $title <<=") . "\n\n"),
          (
           map  { sprintf(q{-> } . "%-*s: %s\n", $opt{_colors} ? 18 : 10, _bold_color($_->[0]), $_->[1]) }
           grep { defined($_->[1]) } (
                                      ['Title'      => $yv_utils->get_title($playlist)],
                                      ['Author'     => $yv_utils->get_channel_title($playlist)],
                                      ['ChannelID'  => $yv_utils->get_channel_id($playlist)],
                                      ['PlaylistID' => ($id =~ m{^/} ? undef : $id)],
                                      ['Videos'     => $yv_utils->set_thousands($yv_utils->get_playlist_item_count($playlist))],
                                      ['Published'  => $yv_utils->get_publication_date($playlist)],
                                     )
          ),
          "$hr\n"
         );

    return 1;
}

sub print_channel_info {
    my ($channel) = @_;

    my $hr = '-' x ($opt{get_term_width} ? get_term_width() : $term_width);

    printf(
           "\n%s\n%s\n%s\n%s\n%s",
           _bold_color('=> Description'),
           $hr,
           wrap_text(
                     i_tab => q{},
                     s_tab => q{},
                     text  => [$yv_utils->get_description($channel) || 'No description available...']
                    ),
           $hr,
           _bold_color('=> URL: ')
          );

    print STDOUT sprintf("https://www.youtube.com/channel/%s", $yv_utils->get_channel_id($channel));

    my $title        = $yv_utils->get_title($channel);
    my $title_length = length($title);
    my $rep          = ($term_width - $title_length) / 2 - 4;

    $rep = 0 if $rep < 0;

    print(
          "\n$hr\n",
          q{ } x $rep => (_bold_color("=>> $title <<=") . "\n\n"),
          (
           map  { sprintf(q{-> } . "%-*s: %s\n", $opt{_colors} ? 20 : 12, _bold_color($_->[0]), $_->[1]) }
           grep { defined($_->[1]) } (
                                      ['Channel'     => $yv_utils->get_title($channel)],
                                      ['ChannelID'   => $yv_utils->get_channel_id($channel)],
                                      ['Country'     => $yv_utils->get_country($channel)],
                                      ['Videos'      => $yv_utils->set_thousands($yv_utils->get_channel_video_count($channel))],
                                      ['Subscribers' => $yv_utils->set_thousands($yv_utils->get_channel_subscriber_count($channel))],
                                      ['Views'       => $yv_utils->set_thousands($yv_utils->get_channel_view_count($channel))],
                                      ['Published'   => $yv_utils->get_publication_date($channel)],
                                     )
          ),
          "$hr\n"
         );

    return 1;
}

sub print_video_info {
    my ($video) = @_;

    $opt{show_video_info} || return 1;

    my $hr = '-' x ($opt{get_term_width} ? get_term_width() : $term_width);

    printf(
           "\n%s\n%s\n%s\n%s\n%s",
           _bold_color('=> Description'),
           $hr,
           wrap_text(
                     i_tab => q{},
                     s_tab => q{},
                     text  => [$yv_utils->get_description($video) || 'No description available...']
                    ),
           $hr,
           _bold_color('=> URL: ')
          );

    print STDOUT sprintf($CONFIG{youtube_video_url}, $yv_utils->get_video_id($video));

    my $title        = $yv_utils->get_title($video);
    my $title_length = length($title);
    my $rep          = ($term_width - $title_length) / 2 - 4;

    $rep = 0 if $rep < 0;

    my $likes          = $yv_utils->get_likes($video);
    my $dislikes       = $yv_utils->get_dislikes($video);
    my $views          = $yv_utils->get_views($video);
    my $comments_count = $yv_utils->get_comments($video);

    print(
          "\n$hr\n",
          q{ } x $rep => (_bold_color("=>> $title <<=") . "\n\n"),
          (
           map  { sprintf(q{-> } . "%-*s: %s\n", $opt{_colors} ? 18 : 10, _bold_color($_->[0]), $_->[1]) }
           grep { defined($_->[1]) } (
                                      ['Channel'    => $yv_utils->get_channel_title($video)],
                                      ['ChannelID'  => $yv_utils->get_channel_id($video)],
                                      ['VideoID'    => $yv_utils->get_video_id($video)],
                                      ['Category'   => $yv_utils->get_category_name($video)],
                                      ['Definition' => $yv_utils->get_definition($video)],
                                      ['Duration'   => $yv_utils->get_time($video)],
                                      ['Likes'      => $yv_utils->set_thousands($likes)],
                                      (
                                       defined($dislikes)
                                       ? ["Dislikes" => $yv_utils->set_thousands($dislikes)]
                                       : ()
                                      ),
                                      ['Rating'    => $yv_utils->get_rating($video)],
                                      ['Comments'  => $yv_utils->set_thousands($comments_count)],
                                      ['Views'     => $yv_utils->set_thousands($views)],
                                      ['Published' => $yv_utils->get_publication_date($video)],
                                     )
          ),
          "$hr\n"
         );

    return 1;
}

sub print_videos {
    my ($results, %args) = @_;

    if (not $yv_utils->has_entries($results)) {
        warn_no_results("video");
    }

    if ($opt{get_term_width}) {
        get_term_width();
    }

    my $url    = $results->{url};
    my $info   = $results->{results} // {};
    my $videos = $info->{items}      // [];

    foreach my $entry (@$videos) {
        if ($yv_utils->is_activity($entry)) {
            my $type = $entry->{snippet}{type};

            if ($type eq 'upload') {
                $entry->{kind} = 'youtube#video';
                $entry->{id}   = $entry->{contentDetails}{upload}{videoId};
            }

            if ($type eq 'playlistItem') {
                $entry->{kind} = 'youtube#video';
                $entry->{id}   = $entry->{contentDetails}{playlistItem}{resourceId}{videoId};
            }

            if ($type eq 'bulletin' and $entry->{contentDetails}{bulletin}{resourceId}{kind} eq 'youtube#video') {
                $entry->{kind} = 'youtube#video';
                $entry->{id}   = $entry->{contentDetails}{bulletin}{resourceId}{videoId};
            }
        }
    }

#<<<
    @$videos = grep {
            ref($_) eq 'HASH' && ref($_->{id}) eq 'HASH'
                ? (exists($_->{id}{kind})
                    ? $yv_utils->is_video($_)
                    : 0)
                : 1
    } @$videos;
#>>>

    if ($opt{shuffle}) {
        require List::Util;
        $videos = [List::Util::shuffle(@{$videos})];
    }

    if (@{$videos} and not $results->{has_extra_info}) {

        my @video_ids       = grep { defined } map { $yv_utils->get_video_id($_) } @{$videos};
        my $content_details = $yv_obj->video_details(join(',', @video_ids), VIDEO_PART);
        my $video_details   = $content_details->{results}{items};

        foreach my $i (0 .. $#{$videos}) {
            @{$videos->[$i]}{qw(id contentDetails statistics snippet)} =
              @{$video_details->[$i]}{qw(id contentDetails statistics snippet)};
        }

        $results->{has_extra_info} = 1;
    }

#<<<
    # Filter out private or deleted videos
    @$videos = grep {
           $yv_utils->get_video_id($_)
       and $yv_utils->get_time($_) ne '00:00'
    } @$videos;

    # Filter out too short videos
    @$videos = grep {
        $yv_utils->get_duration($_) > $opt{video_min_seconds}
    } @$videos if $opt{video_min_seconds};
#>>>

    my @formatted;

    foreach my $i (0 .. $#{$videos}) {

        my $video = $videos->[$i];
        my $entry = $opt{custom_layout_format};

        push @formatted, format_line_result($i, $entry, $video);
    }

    if ($opt{highlight_watched}) {
        foreach my $i (0 .. $#{$videos}) {
            my $video = $videos->[$i];
            if (exists($WATCHED_VIDEOS{$yv_utils->get_video_id($video)})) {
                $formatted[$i] = colored(colorstrip($formatted[$i]), $opt{highlight_color});
            }
        }
    }

    if (@formatted) {
        print "\n" . join("", @formatted);
    }

    if ($opt{play_all} || $opt{play_backwards}) {
        if (@{$videos}) {
            if (
                play_videos(
                            $opt{play_backwards}
                            ? [reverse @{$videos}]
                            : $videos
                           )
              ) {
                if ($opt{play_backwards}) {
                    if (defined $info->{prevPageToken}) {
                        __SUB__->($yv_obj->from_page_token($url, $info->{prevPageToken}), auto => 1);
                    }
                    else {
                        $opt{play_backwards} = 0;
                        warn_first_page();
                        return;
                    }
                }
                else {
                    if (defined $info->{nextPageToken}) {
                        __SUB__->($yv_obj->from_page_token($url, $info->{nextPageToken}), auto => 1);
                    }
                    else {
                        $opt{play_all} = 0;
                        warn_last_page();
                        return;
                    }
                }
            }
            else {
                $opt{play_all}       = 0;
                $opt{play_backwards} = 0;
                __SUB__->($results);
            }
        }
        else {
            $opt{play_all}       = 0;
            $opt{play_backwards} = 0;
        }
    }

    state @keywords;
    if ($args{auto}) { }    # do nothing...
    else {
        @keywords = get_input_for_search();

        if (scalar(@keywords) == 0) {    # only arguments
            __SUB__->($results);
        }
    }

    state @for_search;
    state @for_play;

    my @copy_of_keywords  = @keywords;
    my $contains_keywords = grep { /$non_digit_or_opt_re/ } @keywords;

    while (@keywords) {
        my $key = shift @keywords;
        if ($key =~ /$valid_opt_re/) {

            my $opt = $1;

            if (
                general_options(opt => $opt,
                                res => $videos,)
              ) {
                ## ok
            }
            elsif ($opt =~ /^(?:h|help)\z/) {
                print $complete_help;
                press_enter_to_continue();
            }

            # :page=i, :end, :beg, :last, :first
            elsif ($opt =~ /^(page=(\S+)\z|(last|end|beg|first))/) {

                my $page_number = parse_page_number($+, $info);
                say "\n:: Jumping to page $page_number" if ($page_number > 1);

                if (defined($info->{fromPage}) and ref($info->{fromPage}) eq 'CODE') {
                    my $request = $info->{fromPage}->($page_number);
                    __SUB__->($request, @keywords ? (auto => 1) : ());
                }
                elsif (defined($url)) {
                    my $page_token = $yv_obj->page_token($page_number);
                    my $request    = $yv_obj->from_page_token($url, $page_token);
                    __SUB__->($request, @keywords ? (auto => 1) : ());
                }
                else {
                    warn_no_results('page');
                }
            }

            # :next
            elsif ($opt =~ /^(?:n|next)\z/) {
                if (defined $info->{nextPageToken}) {
                    my $request = $yv_obj->from_page_token($url, $info->{nextPageToken});
                    __SUB__->($request, @keywords ? (auto => 1) : ());
                }
                else {
                    warn_last_page();
                    if ($opt{auto_next_page}) {
                        $opt{auto_next_page} = 0;
                        @copy_of_keywords = ();
                        last;
                    }
                }
            }

            # :back, :previous
            elsif ($opt =~ /^(?:b|back|p|prev|previous)\z/) {
                if (defined $info->{prevPageToken}) {
                    __SUB__->($yv_obj->from_page_token($url, $info->{prevPageToken}), @keywords ? (auto => 1) : ());
                }
                else {
                    warn_first_page();
                }
            }

            # :refresh
            elsif ($opt =~ /^(?:R|refresh)\z/ and defined($url)) {
                @{$videos} = @{$yv_obj->_get_results($url)->{results}{items}};
                $results->{has_extra_info} = 0;
            }

            # :return
            elsif ($opt =~ /^(?:r|return)\z/) {
                return;
            }

            # :author=i, :u=i
            elsif ($opt =~ /^(?:a|author|u|uploads)${digit_or_equal_re}(.*)/) {
                if (my @nums = get_valid_numbers($#{$videos}, $1)) {
                    foreach my $id (@nums) {
                        my $channel_id = $yv_utils->get_channel_id($videos->[$id]);
                        my $request    = $yv_obj->uploads($channel_id);
                        if ($yv_utils->has_entries($request)) {
                            __SUB__->($request);
                        }
                        else {
                            warn_no_results('video');
                        }
                    }
                }
                else {
                    warn_no_thing_selected('video');
                }
            }

            # :s=i, :save=i
            elsif ($opt =~ /^(?:s|save)${digit_or_equal_re}(.*)/) {
                if (my @nums = get_valid_numbers($#{$videos}, $1)) {
                    foreach my $id (@nums) {
                        my $video_id = $yv_utils->get_video_id($videos->[$id]);
                        save_video_to_file($video_id);
                    }
                }
                else {
                    warn_no_thing_selected('video');
                }
            }

            # :rm=i :remove=i
            elsif ($opt =~ /^(?:rm|remove)${digit_or_equal_re}(.*)/) {
                if (my @nums = get_valid_numbers($#{$videos}, $1)) {
                    remove_saved_videos(map { $yv_utils->get_video_id($videos->[$_]) } @nums);
                }
                else {
                    warn_no_thing_selected('video');
                }
            }

            # :sc=i, :save-channel=i
            elsif ($opt =~ /^(?:sc|save-channel)${digit_or_equal_re}(.*)/) {
                if (my @nums = get_valid_numbers($#{$videos}, $1)) {
                    foreach my $id (@nums) {
                        my $channel_id    = $yv_utils->get_channel_id($videos->[$id]);
                        my $channel_title = $yv_utils->get_channel_title($videos->[$id]);
                        save_channel_to_file($channel_id, $channel_title);
                    }
                }
                else {
                    warn_no_thing_selected('video');
                }
            }

            # :popular=i, :pv=i
            elsif ($opt =~ /^(?:pv|popular)${digit_or_equal_re}(.*)/) {
                if (my @nums = get_valid_numbers($#{$videos}, $1)) {
                    foreach my $id (@nums) {
                        my $channel_id = $yv_utils->get_channel_id($videos->[$id]);
                        my $request    = $yv_obj->popular_videos($channel_id);
                        if ($yv_utils->has_entries($request)) {
                            __SUB__->($request);
                        }
                        else {
                            warn_no_results('popular video');
                        }
                    }
                }
                else {
                    warn_no_thing_selected('video');
                }
            }

            # :activity
            elsif ($opt =~ /^(?:A|[Aa]ctivity)${digit_or_equal_re}(.*)/) {
                if (my @nums = get_valid_numbers($#{$videos}, $1)) {
                    foreach my $id (@nums) {
                        my $channel_id = $yv_utils->get_channel_id($videos->[$id]);
                        my $request    = $yv_obj->activities($channel_id);
                        if ($yv_utils->has_entries($request)) {
                            __SUB__->($request);
                        }
                        else {
                            warn_no_results('activity');
                        }
                    }
                }
                else {
                    warn_no_thing_selected('activity');
                }
            }

            # :ps
            elsif ($opt =~ /^(?:ps|s2p)${digit_or_equal_re}(.*)/) {
                if (my @nums = get_valid_numbers($#{$videos}, $1)) {
                    select_and_save_to_playlist(map { $yv_utils->get_video_id($videos->[$_]) } @nums);
                }
                else {
                    warn_no_thing_selected('video');
                }
            }

            # :p=i, :playlist=i, :up=i
            elsif ($opt =~ /^(?:p|l|playlists?|up)${digit_or_equal_re}(.*)/) {
                if (my @nums = get_valid_numbers($#{$videos}, $1)) {
                    foreach my $id (@nums) {
                        my $request = $yv_obj->playlists($yv_utils->get_channel_id($videos->[$id]));
                        if ($yv_utils->has_entries($request)) {
                            print_playlists($request);
                        }
                        else {
                            warn_no_results('playlist');
                        }
                    }
                }
                else {
                    warn_no_thing_selected('video');
                }
            }

            # :like=i, :dislike=i
            elsif ($opt =~ /^((?:dis)?like)${digit_or_equal_re}(.*)/) {
                my $rating = $1;
                if (my @nums = get_valid_numbers($#{$videos}, $2)) {
                    rate_videos($rating, map { $yv_utils->get_video_id($videos->[$_]) } @nums);
                }
                else {
                    warn_no_thing_selected('video');
                }
            }

            # :fav=i, :favorite=i
            elsif ($opt =~ /^(?:fav|favorite|F)${digit_or_equal_re}(.*)/) {
                if (my @nums = get_valid_numbers($#{$videos}, $1)) {
                    favorite_videos(map { $yv_utils->get_video_id($videos->[$_]) } @nums);
                }
                else {
                    warn_no_thing_selected('video');
                }
            }

            # # :sub=i, :subscribe=i
            elsif ($opt =~ /^(?:sub(?:scribe)?|S)${digit_or_equal_re}(.*)/) {
                if (my @nums = get_valid_numbers($#{$videos}, $1)) {
                    subscribe(map { $yv_utils->get_channel_id($videos->[$_]) } @nums);
                }
                else {
                    warn_no_thing_selected('video');
                }
            }

            # :unsub=i, :unsubscribe=i
            elsif ($opt =~ /^(?:unsub(?:scribe)?)${digit_or_equal_re}(.*)/) {
                if (my @nums = get_valid_numbers($#{$videos}, $1)) {
                    unsubscribe(map { $yv_utils->get_channel_id($videos->[$_]) } @nums);
                }
                else {
                    warn_no_thing_selected('video');
                }
            }
            elsif ($opt =~ /^(?:q|queue|enqueue)${digit_or_equal_re}(.*)/) {
                if (my @nums = get_valid_numbers($#{$videos}, $1)) {
                    push @{$opt{_queue_play}}, map { $yv_utils->get_video_id($videos->[$_]) } @nums;
                }
                else {
                    warn_no_thing_selected('video');
                }
            }
            elsif ($opt =~ /^(?:pq|qp|play-queue)\z/) {
                if (ref $opt{_queue_play} eq 'ARRAY' and @{$opt{_queue_play}}) {
                    my $ids = 'v=' . join(q{,}, splice @{$opt{_queue_play}});
                    general_options(opt => $ids);
                }
                else {
                    warn colored("\n[!] The playlist is empty!", 'bold red') . "\n";
                }
            }
            elsif ($opt =~ /^c(?:omments?)?${digit_or_equal_re}(.*)/) {
                if (my @nums = get_valid_numbers($#{$videos}, $1)) {
                    get_and_print_comments(map { $yv_utils->get_video_id($videos->[$_]) } @nums);
                }
                else {
                    warn_no_thing_selected('video');
                }
            }
            elsif ($opt =~ /^r(?:elated)?${digit_or_equal_re}(.*)/) {
                if (my ($id) = get_valid_numbers($#{$videos}, $1)) {
                    get_and_print_related_videos($yv_utils->get_video_id($videos->[$id]));
                }
                else {
                    warn_no_thing_selected('video');
                }
            }
            elsif ($opt =~ /^(?:w|mark)${digit_or_equal_re}(.*)/) {
                if (my @nums = get_valid_numbers($#{$videos}, $1)) {
                    save_watched_video($yv_utils->get_video_id($videos->[$_])) for @nums;
                }
                else {
                    warn_no_thing_selected('video');
                }
            }
            elsif ($opt =~ /^(?:ap|autoplay)${digit_or_equal_re}(.*)/) {
                if (my ($id) = get_valid_numbers($#{$videos}, $1)) {
                    local $opt{autoplay_mode} = 1;
                    play_videos([$videos->[$id]]);
                }
                else {
                    warn_no_thing_selected('video');
                }
            }
            elsif ($opt =~ /^d(?:ownload)?${digit_or_equal_re}(.*)/) {
                if (my @nums = get_valid_numbers($#{$videos}, $1)) {
                    local $opt{download_video} = 1;
                    play_videos([@{$videos}[@nums]]);
                }
                else {
                    warn_no_thing_selected('video');
                }
            }
            elsif ($opt =~ /^(?:play|P)${digit_or_equal_re}(.*)/) {
                if (my @nums = get_valid_numbers($#{$videos}, $1)) {
                    local $opt{download_video} = 0;
                    local $opt{extract_info}   = undef;
                    play_videos([@{$videos}[@nums]]);
                }
                else {
                    warn_no_thing_selected('video');
                }
            }
            elsif ($opt =~ /^i(?:nfo)?${digit_or_equal_re}(.*)/) {
                if (my @nums = get_valid_numbers($#{$videos}, $1)) {
                    foreach my $num (@nums) {
                        local $opt{show_video_info} = 1;
                        print_video_info($videos->[$num]);
                    }
                    press_enter_to_continue();
                }
                else {
                    warn_no_thing_selected('video');
                }
            }
            elsif ($opt eq 'anp') {    # auto-next-page
                $opt{auto_next_page} = 1;
            }
            elsif ($opt eq 'nnp') {    # no-next-page
                $opt{auto_next_page} = 0;
            }
            elsif ($opt =~ /^[ks]re(?:gex)?=(.*)/) {
                my $value = $1;
                if ($value =~ /^([a-zA-Z]++)(?>,|=>)(.+)/) {
                    play_videos_matched_by_regex(
                                                 key    => $1,
                                                 regex  => $2,
                                                 videos => $videos,
                                                )
                      or __SUB__->($results);
                }
                else {
                    warn_invalid("Special Regexp", $value);
                }
            }
            elsif ($opt =~ /^re(?:gex)?=(.*)/) {
                play_videos_matched_by_regex(
                                             key    => 'title',
                                             regex  => $1,
                                             videos => $videos,
                                            )
                  or __SUB__->($results);
            }
            else {
                warn_invalid('option', $opt);
            }
        }
        elsif (youtube_urls($key)) {
            ## ok
        }
        elsif (!$contains_keywords and (valid_num($key, $videos) or $key =~ /$range_num_re/)) {
            my @for_play;
            if ($key =~ /$range_num_re/) {
                my $from = $1;
                my $to   = $2 // do {
                    $opt{auto_next_page} ? do { $from = 1 } : do { $opt{auto_next_page} = 1 };
                    $#{$videos} + 1;
                };
                my @ids = get_valid_numbers($#{$videos}, "$from..$to");
                if (@ids) {
                    push @for_play, @ids;
                }
                else {
                    push @for_search, $key;
                }
            }
            else {
                push @for_play, $key - 1;
            }

            if (@for_play and not play_videos([@{$videos}[@for_play]])) {
                __SUB__->($results);
            }
        }
        else {
            push @for_search, $key;
        }
    }

    if (@for_search) {
        __SUB__->($yv_obj->search_videos([splice(@for_search)]));
    }
    elsif ($opt{auto_next_page}) {
        @keywords = (':next', grep { $_ !~ /^:(n|next|anp)\z/ } @copy_of_keywords);

        if (@keywords > 1) {
            my $timeout = 2;
            print colored("\n:: Press <ENTER> in $timeout seconds to stop the :anp option.", 'bold green');
            eval {
                local $SIG{ALRM} = sub {
                    die "alarm\n";
                };
                alarm $timeout;
                scalar <STDIN>;
                alarm 0;
            };

            if ($@) {
                if ($@ eq "alarm\n") {
                    __SUB__->($results, auto => 1);
                }
                else {
                    warn colored("\n[!] Unexpected error: <$@>.", 'bold red') . "\n";
                }
            }
            else {
                $opt{auto_next_page} = 0;
                __SUB__->($results);
            }
        }
        else {
            warn colored("\n[!] Option ':anp' works only combined with other options!", 'bold red') . "\n";
            $opt{auto_next_page} = 0;
            __SUB__->($results);
        }
    }

    __SUB__->($results) if not $args{auto};

    return 1;
}

sub press_enter_to_continue {
    say '';
    scalar $term->readline(colored("=>> Press ENTER to continue...", 'bold'));
}

sub main_quit {
    exit($_[0] // 0);
}

main_quit(0);

=head1 CONFIGURATION OPTIONS

=head2 auto_captions

When set to C<1>, auto-generated captions will be retrieved. By default, auto-generated captions are ignored.

=head2 audio_quality

The preferred quality for the audio-track:

    best        # best audio quality available (<=192kbps)
    medium      # medium audio quality (<=128kbps)
    low         # low audio quality (<=50kbps)

The option can also be set to a numeric value N in order to select an audio-track with <= Nkbps.

=head2 autoplay_mode

Enable autoplay mode, which will continuously play related videos.

=head2 bypass_age_gate_native

Bypass age-restricted videos, using our internal method.

However, these streaming URLs are heavily throttled by YouTube.

When this option is disabled, a fallback method will be used instead (C<yt-dlp>/C<youtube-dl> or invidious instances).

=head2 bypass_age_gate_with_proxy

Bypass age-restricted videos using an YouTube Account Proxy.

=head2 cache_dir

Cache directory where to save temporary files.

=head2 colors

Use colors for text.

=head2 comments_order

The sorting order for comments. Valid values: "time", "relevance".

=head2 confirm

Display a confirmation message after each video played.

=head2 convert_cmd

Command to convert videos.

Default value:

    "ffmpeg -i *IN* *OUT*"

B<*IN*> gets replaced with the input file.

B<*OUT*> gets replaced with the output file.

=head2 convert_to

Format to convert each downloaded video into. (e.g.: C<"mp3">).

=head2 cookie_file

Load cookies from a file. Useful to overcome the "429: Too Many Requests" issue.

The file must be a C<# Netscape HTTP Cookie File>. Same format as C<youtube-dl> requires.

See also:

    https://github.com/ytdl-org/youtube-dl#how-do-i-pass-cookies-to-youtube-dl

=head2 copy_caption

When downloading a video, copy the closed-caption (if any) in the same folder with the video.

If C<merge_into_mkv> and C<merge_with_captions> are both enabled, there is no need to enable this option.

=head2 custom_layout_format

An array of hash values specifying a custom layout for video results.

    align       # "left" or "right"
    color       # any color supported by Term::ANSIColor
    text        # the actual text
    width       # width allocated for the text

The value for C<width> can be either a number of characters (e.g.: 20) or can be a percentage of the terminal width (e.g.: "15%").

The special tokens for C<text> are listed in:

    youtube-viewer --tricks

For better formatting, it's highly recommended to install L<Unicode::GCString> or L<Text::CharWidth>.

=head2 custom_channel_layout_format

An array of hash values specifying a custom layout for channel results.

=head2 custom_playlist_layout_format

An array of hash values specifying a custom layout for playlist results.

=head2 dash_segmented

Include or exclude streams in "Dynamic Adaptive Streaming over HTTP" (DASH) format.

=head2 debug

Enable debug/verbose mode, which will print some extra information.

Valid values: 0, 1, 2, 3.

=head2 download_and_play

Play downloaded videos.

=head2 download_with_wget

Download videos with C<wget>.

=head2 download_with_ytdl

Download videos with `yt-dlp` or `youtube-dl`.

By enabling this option and setting the value of C<ytdl_cmd> to C<"yt-dlp">, download speed will be greatly improved.

=head2 downloads_dir

Directory where to download files and where to save converted files.

=head2 env_proxy

Load proxy settings from C<*_proxy> environment variables (if any).

=head2 fat32safe

When downloading a video, make the filename compatible with the FAT32 filesystem.

Additionally, if L<Text::Unidecode> is available, then Unicode characters are converted to ASCII equivalents.

=head2 ffmpeg_cmd

Path to the C<ffmpeg> program.

=head2 force_fallback

Force the extraction of the streaming URLs to always use the fallback method (youtube-dl / invidious).

=head2 fullscreen

Play videos in fullscreen mode.

=head2 get_captions

Download closed-captions for videos (if any).

=head2 get_term_width

Read the terminal width (`stty size`).

=head2 hfr

Prefer or ignore High Frame Rate (HFR) video streams.

Try to disable this option if the videos are lagging or dropping frames.

=head2 highlight_color

Highlight color used to highlight watched videos.

Any color supported by L<Term::ANSIColor> can be used.

=head2 highlight_watched

Highlight watched videos.

=head2 history

Enable or disable support for input history.

Requires L<Term::ReadLine::Gnu>.

=head2 history_file

File where to save the input history.

=head2 history_limit

Maximum number of entries in the history file.

When the limit is reached, the first half of the history file will be deleted.

Set the value to C<-1> for no limit.

=head2 hl

Language code for categories. Default: "en_US".

=head2 http_proxy

Set HTTP(S)/SOCKS proxy, using the format:

    'proto://domain.tld:port/'

If authentication is required, use:

    'proto://user:pass@domain.tld:port/'

For example, to use Tor, install L<LWP::Protocol::socks> and set this value to:

    "socks://127.0.0.1:9050"

=head2 ignore_av1

Ignore videos in AV1 format.

=head2 ignored_projections

An array of video projections to ignore.

For example, to prefer rectangular projections of 360° videos, use:

    ignored_projections => ["mesh", "equirectangular"],

=head2 interactive

Interactive mode, prompting for user-input.

=head2 keep_original_video

Keep the original video after conversion. When set to C<0>, the original video will be deleted.

=head2 maxResults

How many results to display per page.

=head2 merge_into_mkv

During download, merge the audio+video files into an MKV container.

Requires C<ffmpeg>.

=head2 merge_into_mkv_args

Arguments for C<ffmpeg> how to merge the files.

=head2 merge_with_captions

Include closed-captions inside the MKV container (if any).

=head2 order

Search order for videos.

Valid values:

    date       – Sorted in reverse chronological order.
    rating     – Sorted from highest to lowest rating.
    relevance  – By relevance to the search query. (default)
    title      – Sorted alphabetically by title.
    videoCount – Sory by number of videos (for channels).
    viewCount  – Sorted from highest to lowest number of views.

=head2 page

Page number of results.

=head2 prefer_av1

Prefer videos in AV1 format. (just for testing)

=head2 prefer_mp4

Prefer videos in MP4 (AVC) format.

Try to enable this option if the videos are lagging or dropping frames.

=head2 prefer_m4a

Prefer audio streams in M4A (AAC) format.

By default, the OPUS format for audio is preferred.

=head2 publishedAfter

The C<publishedAfter> option indicates that the API response should only contain resources created at or after the specified time. The value is an RFC 3339 formatted date-time value (1970-01-01T00:00:00Z).

=head2 publishedBefore

The C<publishedBefore> option indicates that the API response should only contain resources created before or at the specified time. The value is an RFC 3339 formatted date-time value (1970-01-01T00:00:00Z).

=head2 regionCode

The C<regionCode> option instructs the API to return search results for videos that can be viewed in the specified country. The parameter value is an ISO 3166-1 alpha-2 country code. (default: "US")

=head2 remove_played_file

When C<download_and_play> is enabled, remove the file after playing it.

=head2 resolution

Preferred resolution for videos.

Valid values: best, 2160p, 1440p, 1080p, 720p, 480p, 360p, 240p, 144p, audio.

=head2 safeSearch

The C<safeSearch> option indicates whether the search results should include restricted content as well as standard content.

Valid values: "strict", "moderate", "none".

=head2 show_video_info

Show extra info for videos when selected.

=head2 skip_if_exists

When downloading, skip if the file already exists locally.

=head2 skip_watched

Skip already watched/downloaded videos.

=head2 split_videos

Enable or disable support for split videos. Split-videos are videos that do not include audio and video in the same file.

Disable this option if the videos are loading too slowly, as non-split videos are not throttled by YouTube. Although, the highest resolution of non-split videos is 360p.

=head2 srt_languages

List of SRT languages in the order of preference.

=head2 subscriptions_order

Sorting order for subscriptions.

Valid values:

    alphabetical – Sort alphabetically.
    relevance    – Sort by relevance.
    unread       – Sort by order of activity.

=head2 subscription_videos_per_channel

How many recent videos to fetch from each channel in local subscription videos (C<-ls>).

Valid values are between 1 and 50.

=head2 thousand_separator

Thousands separator character for numbers >= 1000.

=head2 timeout

HTTPS timeout value in seconds. The default value is 10 seconds.

=head2 user_agent

Token that is used to identify the user agent on the network. The agent value is sent as the C<User-Agent> header in the requests.

=head2 video_filename_format

The format of filename for downloaded files.

The available special tokens are listed in:

    youtube-viewer --tricks

=head2 video_min_seconds

Filter out from results videos with less than C<video_min_seconds> seconds.

=head2 video_player_selected

The selected video player defined the C<video_players> table.

=head2 video_players

A table of video players.

The keys for each player are:

    arg        # any arguments for the video player
    audio      # option specifying the *AUDIO* file
    cmd        # the main player command
    fs         # the fullscreen option
    novideo    # the no-video mode option
    srt        # option specifying the *SUB* file

=head2 videoCaption

The C<videoCaption> option indicates whether the API should filter video search results based on whether they have captions.

Valid values:

    any           – Do not filter results based on caption availability.
    closedCaption – Only include videos that have captions.
    none          – Only include videos that do not have captions.

=head2 videoDefinition

The C<videoDefinition> option lets you restrict a search to only include either high definition (HD) or standard definition (SD) videos.

Valid values:

    any      – Return all videos, regardless of their resolution.
    high     – Only retrieve HD videos.
    standard – Only retrieve videos in standard definition.

=head2 videoDimension

The C<videoDimension> option lets you restrict a search to only retrieve 2D or 3D videos.

Valid values:

    2d  – Restrict search results to exclude 3D videos.
    3d  – Restrict search results to only include 3D videos.
    any – Include both 3D and non-3D videos in returned results.

=head2 videoDuration

The C<videoDuration> parameter filters video search results based on their duration.

Valid values: "any", "short", "long".

Valid values:

    any     – Do not filter video search results based on their duration.
    long    – Only include videos longer than 20 minutes.
    medium  – Only include videos that are between 4-20 minutes.
    short   – Only include videos that are less than 4 minutes long.

=head2 videoLicense

The C<videoLicense> option filters search results to only include videos with a particular license.

Valid values:

    any            – All videos, regardless of which license they have.
    creativeCommon – Only return videos that have a "Creative Commons" license.
    youtube        – Only return videos that have the standard YouTube license.

=head2 videoSyndicated

The C<videoSyndicated> option lets you to restrict a search to only videos that can be played outside B<youtube.com>.

Valid values:

    any  – Return all videos, syndicated or not.
    true – Only retrieve syndicated videos.

=head2 watch_history

Remember watched videos across multiple sessions.

The video IDs are saved in the filename specified by C<watch_history_file>.

This option is also required for C<--watched-videos>.

=head2 watch_history_file

File where to save the video IDs of watched/downloaded videos when C<watch_history> is set to a true value.

=head2 wget_cmd

Command for C<wget> when C<download_with_wget> is set to a true value.

=head2 youtube_users_file

Path to a list of YouTube channels, using the following format:

    ChannelID NAME

The channels can be listed with the command-line option: C<-fc>.

=head2 youtube_video_url

Format for C<sprintf()> for constructing an YouTube video URL given the video ID.

=head2 ytdl

Use C<youtube-dl> for videos with encrypted signatures.

When set to C<0>, invidious instances will be used instead.

=head2 ytdl_cmd

Command for C<yt-dlp> or C<youtube-dl> when C<ytdl> is set to a true value.

=head1 CONFIGURATION FILES

The configuration files are:

    ~/.config/youtube-viewer/youtube-viewer.conf
    ~/.config/youtube-viewer/gtk-youtube-viewer.conf

=head1 YOUTUBE API REFERENCE

https://developers.google.com/youtube/v3/docs/

=head1 REPOSITORY

https://github.com/trizen/youtube-viewer

=head1 LICENSE AND COPYRIGHT

Copyright 2010-2024 Trizen.

This program is free software; you can redistribute it and/or modify it
under the terms of either: the GNU General Public License as published
by the Free Software Foundation; or the Artistic License.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

See L<https://dev.perl.org/licenses/> for more information.

=cut
